<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郑彧</title>
  <subtitle>郑彧</subtitle>
  <link href="/note/atom.xml" rel="self"/>
  
  <link href="http://yu-zhengyu.github.com/note/"/>
  <updated>2016-05-19T02:02:32.000Z</updated>
  <id>http://yu-zhengyu.github.com/note/</id>
  
  <author>
    <name>郑彧 Yu Zheng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>毕业之后</title>
    <link href="http://yu-zhengyu.github.com/note/2016/05/16/%E6%AF%95%E4%B8%9A%E4%B9%8B%E5%90%8E/"/>
    <id>http://yu-zhengyu.github.com/note/2016/05/16/毕业之后/</id>
    <published>2016-05-16T20:49:02.000Z</published>
    <updated>2016-05-19T02:02:32.000Z</updated>
    
    <content type="html">&lt;p&gt;昨天结束了硕士阶段，有没有博士阶段不知道，但是校园生活就先暂时结束了。实在是没事干，随手记录一下硕士阶段的事情，免得以后更没这个闲情（其实就是懒）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;最近等 EAD 卡真的等到烦了，美国政府办事力度真的是要多慢有多慢，现在来美国留学的人越来越多，他们就不能想想办法增派一下人手，网站信息更新的也莫名其妙，让人也不知道现在是个什么阶段，至少让我知道需不需要补材料什么的（也知道怪自己当时拖延症，太晚寄材料，现在只能哭死......）。

莫名其妙就毕业了，我自己都吓一跳。本科毕业的时候没什么感觉，因为当时研究生第一年还是呆在中大，所以并没有感到多么伤感，反而是搬去顺德研究院后，有一点离别的感觉，可是当时毕业的劲头也已经过了，感觉自己没有真正体会过“毕业”。

这一次，嗯......啊......好像更没什么感觉了......

这一次毕业好像就是领个证，参加完一个典礼，和同学照照相，就这么过了。晚上8，9点回到家里，倒头就睡到了第二天的10点，第二天起来，发现也没办法干什么，也学习不下。只好整理整理一下两年研究生的生活，虽然也没什么可圈可点的地方。

当时为什么继续读研究生而不去工作，具体是什么理由，其实我自己都忘了。刚开始的时候是想打算好好学习，让自己的技能点加得更多的，然而这个东西就和你每年暑假往书包塞一堆书，然后回到家后整个暑假连书包拉链都没碰过一样。研究生阶段感觉自己并没有比本科的时候努力，幸好每门课的 deadline 还是在后面催着，几乎是每个星期都催，强迫你没办法不认真学习，但是，有时候真的也没有太多时间去专研技术，机会有时候就是硬写作业了，至于现在我什么能力，估计和本科没啥两样吧。

其实还是很幸运的，应该说，刚好能和这群人在一起是挺难得的，因为我能够从和同学一起学习之中看到了自己的不足，然后，渐渐习惯了自己的不足OrZ......虽然初中的时候就接受了自己不聪明的事实，但是有时候被天才直接碾压的时候，还是只能苦笑，然后尽力跑一跑，希望可以尽量望一下他们的虎背。

现在天天就想着回国，真的好怀恋肠粉啊，早茶啊，撸串什么的，一想到这些东西真的就一刻都不想呆在这里了。老实说，如果明天就收到卡，立刻买晚上的机票回国这种事情我还是做的出的。我是不太理解美国人日常的娱乐了，如果不去 pub 或则 bar，我觉得美国人真的是会无聊死吧。想想在国内，晚上12点或者是1点走在大街上我都觉得还好，但是在这边，10点钟我就觉得怕怕的，加上大家的渲染，感觉随时能够遇到黑哥哥......

完了，也不知道是自己表达能力下降了还是自己生活实在是太无聊，本来感觉应该很多东西想写的，但是手放到键盘上又不知道打些什么。看来我还是喜欢约三五个好友，一起出来喝喝茶，吃个包，聊聊天，像个老头一样生活。本来还说能不能靠写博客段子当一个网红，现在想想还是算了吧......

预计6月回国吧，希望事情一切顺利。回去以后大家约约约啊！！！！！不约不是人~~~~
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;昨天结束了硕士阶段，有没有博士阶段不知道，但是校园生活就先暂时结束了。实在是没事干，随手记录一下硕士阶段的事情，免得以后更没这个闲情（其实就是懒）。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yu-zhengyu.github.com/note/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="毕业" scheme="http://yu-zhengyu.github.com/note/tags/%E6%AF%95%E4%B8%9A/"/>
    
  </entry>
  
  <entry>
    <title>找工作二三事</title>
    <link href="http://yu-zhengyu.github.com/note/2016/04/02/%E6%89%BE%E5%B7%A5%E4%BD%9C%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
    <id>http://yu-zhengyu.github.com/note/2016/04/02/找工作二三事/</id>
    <published>2016-04-02T05:21:21.000Z</published>
    <updated>2016-05-16T21:01:33.000Z</updated>
    
    <content type="html">&lt;p&gt;最近精神太萎靡了，浪得太过分了。做人没有梦想，和咸鱼有什么区别，所以我想说的是，请让我当一条咸到发臭的鱼。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://static.apple.nextmedia.com/images/apple-photos/apple/20131214/large/14ec1p10.jpg&quot; width=&quot;300&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;后找工作时期的自己&quot;&gt;&lt;a href=&quot;#后找工作时期的自己&quot; class=&quot;headerlink&quot; title=&quot;后找工作时期的自己&quot;&gt;&lt;/a&gt;后找工作时期的自己&lt;/h2&gt;&lt;p&gt;找工作是一件很烦，很烦，很烦的事情，这个过程其实很痛苦，有点像高考前2个月的情况，而且这个过程还要穿插在 CMU 高强度的学习之下，就更难受了。我们项目因为只有一年的时间，必须保证选择三门课来保证我们 full-time 的身份，所以，选水课保工作，还是选好课让自己的学费别白费，这个权衡就很难说了，大家见仁见智吧。&lt;/p&gt;
&lt;p&gt;其实经验这个东西，对我来说，意义不大，因为我发现，我对别人的经验没有转换的能力。所以对我自己来说，可能还是自己瞎 XX 闯后得到的教训能让自己印象深刻吧。&lt;/p&gt;
&lt;p&gt;总体来说，我觉得两点很重要（当然是你自己的实力别太差的情况下）：时机和运气。这个东西我觉得真的要自己去体会了，我觉得，如果你开始找后，你会理解我说的话。&lt;/p&gt;
&lt;p&gt;但是。。。。。。千万不要太相信自己的运气了。有时候，生活就像火车便当里面的虫子，总在你满心欢喜的时候，冒出来恶心你一下。可是，你肚子饿呀。。。。。。所以你还是要把它挑走后，继续吃（因为一份便当真 TM 贵。。。。。。）。本人活生生例子，收到亚马逊群面的通知后，我开始知道，自己靠运气这条路肯定没办法走下去了，接下来，也只能靠我的脸撑下去了……(最后还是运气好拿下了)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.doutula.com/production/uploads/image//2015/12/11/20151211807190_kVpvyx.jpg&quot; width=&quot;300&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
&lt;p&gt;怎么说呢，JIE班上老司机太多，有像&lt;a href=&quot;http://wdxtub.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;土刀哥&lt;/a&gt;，shushan,  &lt;a href=&quot;http://jackqdyulei.github.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jack Yu&lt;/a&gt;这些老司机带着大家，其实已经很够了。刷题方面，除了小土刀的外，我室友&lt;a href=&quot;http://smartyi8979.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;smart Yi的博客&lt;/a&gt;也是我每天必刷的。他的励志故事可以开一个长篇来叙述。反正虽然他是物理出身，但是算法方面早已经超我两条街了(一条街叫 Morewood，另一条叫shadyside)……所以我就提供一些边角料好了，希望能够给大家一点点参考。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;门面装逼篇&quot;&gt;&lt;a href=&quot;#门面装逼篇&quot; class=&quot;headerlink&quot; title=&quot;门面装逼篇&quot;&gt;&lt;/a&gt;门面装逼篇&lt;/h2&gt;&lt;p&gt;首先我给自己弄了两份(准确来说是三分吧)简历。一份是 CMU 官方模板做的，一份是 guangsdick 推荐给我的，一份是网页版的简历。CMU 的官方文档我就费事给出了，反正网上随便搜索一下就下载到了。我给出一个在线编译 LaTeX的网站，上面有一些挺好的模板，大家可以拿下来用一下，那个是我的第二份简历。第三份简历是在我的个人网站上，我也贴出，源代码在网站的最下面，可以通过超链接找到 github 原版的模板，当然你也可以把我的 fork 下来。&lt;/p&gt;
&lt;h3 id=&quot;简历1。0相关连接&quot;&gt;&lt;a href=&quot;#简历1。0相关连接&quot; class=&quot;headerlink&quot; title=&quot;简历1。0相关连接&quot;&gt;&lt;/a&gt;简历1。0相关连接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://drive.google.com/file/d/0B-OuuTmPszQBWDV5WXdNd0gyeTQ/view?usp=sharing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我的1。0版简历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;简历2。0相关连接：&quot;&gt;&lt;a href=&quot;#简历2。0相关连接：&quot; class=&quot;headerlink&quot; title=&quot;简历2。0相关连接：&quot;&gt;&lt;/a&gt;简历2。0相关连接：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://drive.google.com/file/d/0B-OuuTmPszQBU0Jkd3BUWGVaak0/view?usp=sharing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我的2。0版简历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.overleaf.com/latex/templates/deedy-resume/sqdbztjjghvz#.Vv9riRMrK2m&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;在线编译 LaTex 网站&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;简历3。0相关连接：&quot;&gt;&lt;a href=&quot;#简历3。0相关连接：&quot; class=&quot;headerlink&quot; title=&quot;简历3。0相关连接：&quot;&gt;&lt;/a&gt;简历3。0相关连接：&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://yu-zhengyu.github.io/RESUME/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我的3。0版简历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;利器篇&quot;&gt;&lt;a href=&quot;#利器篇&quot; class=&quot;headerlink&quot; title=&quot;利器篇&quot;&gt;&lt;/a&gt;利器篇&lt;/h2&gt;&lt;p&gt;在国内，我用的比较多的就是51job， 智联招聘还有大街网。不过都是大三找实习时候用的，反正给我的感觉就是挺乱的。&lt;/p&gt;
&lt;p&gt;来到这里我主要用下面几个投简历还有收集公司(按照使用频率和重要程度排序)：LinkedIn，glassdoor， ziprecruiter还有beyond。&lt;/p&gt;
&lt;p&gt;我觉得，用上面4个都很够了。主要还是每天都花点时间看看就好。累计下来其实我投了大概100~200家之间吧。(说来惭愧，自从拿了亚麻之后，很多直接就推掉了，现在想想自己真的是太浪费了。。。。。。)。&lt;/p&gt;
&lt;p&gt;LinkIn 还是好好维护一下，有时候还是会有小惊喜的，有三家是 HR 直接从 LinkedIn 上直接找到我的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linkedin.com/in/yuzhengcmu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;我的 LinkedIn&lt;/a&gt; 其实我觉得是不太好的，不过大家有兴趣也能参考一下。对了，记得把自己 LinkedIn 的链接地址改改，我的就是改成了&lt;a href=&quot;https://www.linkedin.com/in/yuzhengcmu，&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.linkedin.com/in/yuzhengcmu，&lt;/a&gt; 别一直用随机生成的字符，太 low 了。。。。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;不要脸篇（找内推）&quot;&gt;&lt;a href=&quot;#不要脸篇（找内推）&quot; class=&quot;headerlink&quot; title=&quot;不要脸篇（找内推）&quot;&gt;&lt;/a&gt;不要脸篇（找内推）&lt;/h2&gt;&lt;p&gt;内推这个东西，我觉得大公司和创业公司还是挺有用的，但是也不尽然吧。我的话，除了 FLAG，雅虎，甲骨文 是找内推的外，其他都是网投的了。所以，除了你的朋友外，多数情况下，还是在一*三分地找的海推，或者在 LinkedIn 或者小伙伴那里收刮来的 HR 邮箱请别人帮帮忙。下面我贴上我自己邮件的内容，大家参考一下，最好能够写出自己的特色吧。中文的我是参考了&lt;a href=&quot;http://wdxtub.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;网红小土刀&lt;/a&gt;的，英文我是自己瞎掰的，然后找 Victor 改的，如果有错请不要打我脸。&lt;/p&gt;
&lt;h3 id=&quot;邮件1。0中文版&quot;&gt;&lt;a href=&quot;#邮件1。0中文版&quot; class=&quot;headerlink&quot; title=&quot;邮件1。0中文版&quot;&gt;&lt;/a&gt;邮件1。0中文版&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;楼主您好：&lt;br&gt;我叫郑彧(Yu Zheng)，现在是 CMU 的 Graduate 在读，2016年5月毕业。在地里看到您的信息，希望能够找您内推 New Grad software Engineer。&lt;br&gt;我本科是在中山大学就读，专业是软件工程，现在在 Carnegie Mellon University 读 Electrical and Computer Engineering的Master。对移动开发和机器学习比较感兴趣。在学校做过移动开发（安卓和WP），PC客户端开发，游戏开发，现在也在学习 cloud computing。比较熟悉的语言是 Java， C++，C#， Python， matlab。连接是我的简历。冒昧打扰了。&lt;/p&gt;
&lt;p&gt;手机：4123535957&lt;/p&gt;
&lt;p&gt;Linkedin：&lt;a href=&quot;https://www.linkedin.com/in/yuzhengcmu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.linkedin.com/in/yuzhengcmu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;website: &lt;a href=&quot;https://yu-zhengyu.github.com&quot;&gt;https://yu-zhengyu.github.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;希望得到机会。好人一生平安&lt;del&gt;~&lt;/del&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;邮件1。0英文版（其实我的-Cover-Letter和这个也差不多）&quot;&gt;&lt;a href=&quot;#邮件1。0英文版（其实我的-Cover-Letter和这个也差不多）&quot; class=&quot;headerlink&quot; title=&quot;邮件1。0英文版（其实我的 Cover Letter和这个也差不多）&quot;&gt;&lt;/a&gt;邮件1。0英文版（其实我的 Cover Letter和这个也差不多）&lt;/h3&gt;&lt;p&gt;Victor 在改我的邮件的时候，给我一条意见我觉得挺中肯的，就是要让人看完你的邮件后觉得你很有企图心。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HI，&lt;/p&gt;
&lt;p&gt;My name is Yu Zheng。 I’m a masters student at CMU majoring in Electrical and Computer Engineering。 As I am graduating this May 2016， I am now seeking for full-time job opportunities。&lt;/p&gt;
&lt;p&gt;When I was in college I did some projects， such as WindowsPhone app development， PC Client development， PC game design and so on。 By doing these projects， I was able to equip myself with a skill set of programming languages such as JAVA， Python， C/C++， C# javascript and Matlab。 In my graduate studies at CMU， I worked on speech recognition and machine learning projects while I continued developing android apps。&lt;/p&gt;
&lt;p&gt;I saw the information of your company in CMU job system and highly hope can get the interview opportunity of software Engineering(new grad) of Yours。 I’m a fast learner and a good team player。 My personal information can be found in the following link。  Please also find my resume in the attachment。 Hope you can spend some time to review my resume。&lt;/p&gt;
&lt;p&gt;phone：4123535957&lt;/p&gt;
&lt;p&gt;Linkedin：&lt;a href=&quot;https://www.linkedin.com/in/yuzhengcmu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.linkedin.com/in/yuzhengcmu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Website: &lt;a href=&quot;http://yu-zhengyu.github.com/&quot;&gt;http://yu-zhengyu.github.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thank you! I look forward to hearing from you soon。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;邮件混合版&quot;&gt;&lt;a href=&quot;#邮件混合版&quot; class=&quot;headerlink&quot; title=&quot;邮件混合版&quot;&gt;&lt;/a&gt;邮件混合版&lt;/h3&gt;&lt;p&gt;后来，有些内推人喜欢说附上英文的第三人人称自我介绍，我又换了一种形式，反正，随机应变，别人想要啥我就给啥就是了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;楼主你好。&lt;br&gt;在地里看到你的内推消息，希望能够得到内推的机会，万分感谢。下面是我的个人介绍。&lt;/p&gt;
&lt;p&gt;Yu Zheng， he is a masters student at CMU majoring in Electrical and Computer Engineering。 He will graduate at May 2016。 He also received his Bachelor’s Degree in Software Engineering from Sun Yet-sen University。 &lt;/p&gt;
&lt;p&gt;He has much development experience， such as WindowsPhone app development， PC Client development， PC game design and so on。 His skilled programming languages are Java， python， C/C++， and C#。 Now， He’s also taking course about Cloud computing and Machine Learning in graduate school。&lt;/p&gt;
&lt;p&gt;He is a fast learner and a good team player， and would be very suitable for being a software engineer。&lt;/p&gt;
&lt;p&gt;谢谢，希望能够有机会。&lt;/p&gt;
&lt;p&gt;手机：4123535957&lt;/p&gt;
&lt;p&gt;Linkedin：&lt;a href=&quot;https://www.linkedin.com/in/yuzhengcmu&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.linkedin.com/in/yuzhengcmu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;website: &lt;a href=&quot;https://yu-zhengyu.github.com&quot;&gt;https://yu-zhengyu.github.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;估计大家发现了，反正都是大同小异，不过有条理地分开写写，到时候粘贴就好，毕竟一天可能会发上很多封，提前准备好之后，你就能像机器一样投简历了。。。。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;公司信息篇&quot;&gt;&lt;a href=&quot;#公司信息篇&quot; class=&quot;headerlink&quot; title=&quot;公司信息篇&quot;&gt;&lt;/a&gt;公司信息篇&lt;/h2&gt;&lt;p&gt;来到了美国，最糟糕的事情就是信息不对称。在中国，其实也差不多，大家能说的上名字的公司并不多。在美国，认识的就更少了。有好几次都是我回来后告诉大家XX 公司，大家猜开始一窝蜂的投，有些可能慢了，再投就没戏了。为了节省一点大家时间，我就把我海投的，并且得到 HR 回复的公司贴出来，还有班上大神拿到 offer 的公司我也列出来，大家可以都关注一下。我其实从上周开始又进入了投简历的工作当中，一方面给大家当个先锋，另一方面也争取再出去旅游一番吧。&lt;/p&gt;
&lt;p&gt;我就列出公司名，大家直接在 google 上直接搜公司名+career 就可以搜到投简历的地方了。有一些特殊的我就会直接贴出网址。&lt;/p&gt;
&lt;h3 id=&quot;理我的&quot;&gt;&lt;a href=&quot;#理我的&quot; class=&quot;headerlink&quot; title=&quot;理我的&quot;&gt;&lt;/a&gt;理我的&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;这部分持续更新好了，只要一有新的不知名但是很好的公司理我，我就贴出来&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FLAG 略去了， JIE 现在除了 L 之外，都有人了。L 本来有的，然而这又是另一个故事了（一不小心黑了一波大师兄）。&lt;/li&gt;
&lt;li&gt;Two Sigma，永远的痛。。。。。。做对冲基金的，bar 很高。Onsite 挂。&lt;/li&gt;
&lt;li&gt;VMturbo，云计算虚拟机管理公司，几年时间把 VMware 打怕了。会先做 OA，题简单。也可以找这个人内推adam.pasti@vmturbo.com&lt;/li&gt;
&lt;li&gt;BlackRock，LinkedIn，纽约做股票和基金管理的，问的问题很广泛。&lt;/li&gt;
&lt;li&gt;Uber，当时在西雅图面试时候投的，网站和 google 搜出来的不太一样。特别贴出：&lt;a href=&quot;https://careers-uber.icims.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://careers-uber.icims.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;BrightEdge， 加州一个做 ML 和数据可视化的公司，招Software Engineer，面普通的算法，所以可以一试。上周主动找的我，所以应该最近特别缺人。毕竟都缺到连我都找了。&lt;/li&gt;
&lt;li&gt;Signifyd，加州一个用 ML 分析用户和商户欺诈行为的公司，好多大公司都找他们分析数据，国内也有一家公司模仿。也是上周主动找的我，做后端，要求都是 CC 课上学过的。可以一战。&lt;/li&gt;
&lt;li&gt;NVIDIA，上两周找上门的，然而我当时傻逼没理他们，因为刚好在我面 google 前一周。大家可以一试。&lt;/li&gt;
&lt;li&gt;SAP，美国分部没理我，中国分部找上门来了。。。。。。&lt;/li&gt;
&lt;li&gt;Pocket Gem， 被三哥哥黑了一把，悲剧了，不过工资不太高，加州11W。&lt;/li&gt;
&lt;li&gt;saleFoce，不知道当时为什么以 senior 的程度面我。。。。。。&lt;/li&gt;
&lt;li&gt;Apple，说好约了时间，然后就没有然后了，但是他们家的网站天天放新位置，大家没事就去投一两个占坑好了。&lt;/li&gt;
&lt;li&gt;Pinterest，个人很喜欢的一个独角兽，可惜已经签约了，随便面了一下，报的是 Data Engineer 的职位。&lt;br&gt;。。。。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;虽然没理我或者还没理我，但是5星推荐&quot;&gt;&lt;a href=&quot;#虽然没理我或者还没理我，但是5星推荐&quot; class=&quot;headerlink&quot; title=&quot;虽然没理我或者还没理我，但是5星推荐&quot;&gt;&lt;/a&gt;虽然没理我或者还没理我，但是5星推荐&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Houzz， 真心好公司，虽然我的简历拒了，但是听说有人拿到了，而且 onsite 是订套房。。。。。。&lt;/li&gt;
&lt;li&gt;Yelp， 最近又似乎开始大大大招了。&lt;/li&gt;
&lt;li&gt;Indeed，我知道有其他学校的朋友最近拿到 onsite 了，班上大神也拿到过 offer，应该很不错。&lt;/li&gt;
&lt;li&gt;Zillow， 有班上大神拿到 offer，然而并不理我。。。。。。。哭倒在厕所&lt;/li&gt;
&lt;li&gt;tripadvisor， 还没理我，但是我有朋友拿到了 offer，bar 不高，可以一战，在波士顿。&lt;/li&gt;
&lt;li&gt;VMware，暂时没理我，不过听说不错。&lt;/li&gt;
&lt;li&gt;dropbox，没理我。。。。。。。伙食给10颗星。&lt;/li&gt;
&lt;li&gt;Twitter，给了 OA，不记得做。。。。。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;未完待续&quot;&gt;&lt;a href=&quot;#未完待续&quot; class=&quot;headerlink&quot; title=&quot;未完待续&quot;&gt;&lt;/a&gt;未完待续&lt;/h2&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;最近精神太萎靡了，浪得太过分了。做人没有梦想，和咸鱼有什么区别，所以我想说的是，请让我当一条咸到发臭的鱼。&lt;/p&gt;
    
    </summary>
    
      <category term="找工作" scheme="http://yu-zhengyu.github.com/note/categories/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="找工作" scheme="http://yu-zhengyu.github.com/note/tags/%E6%89%BE%E5%B7%A5%E4%BD%9C/"/>
    
      <category term="信息" scheme="http://yu-zhengyu.github.com/note/tags/%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>Best-time-buy-and-sell-stock --- leetcode 买卖股票问题</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/24/leetcode%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/24/leetcode 买卖股票问题/</id>
    <published>2016-01-24T14:22:30.000Z</published>
    <updated>2016-04-02T05:08:04.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;level-1&quot;&gt;&lt;a href=&quot;#level-1&quot; class=&quot;headerlink&quot; title=&quot;level 1&quot;&gt;&lt;/a&gt;level 1&lt;/h1&gt;&lt;h2 id=&quot;121-Best-Time-to-Buy-and-Sell-Stock&quot;&gt;&lt;a href=&quot;#121-Best-Time-to-Buy-and-Sell-Stock&quot; class=&quot;headerlink&quot; title=&quot;121. Best Time to Buy and Sell Stock&quot;&gt;&lt;/a&gt;121. Best Time to Buy and Sell Stock&lt;/h2&gt;&lt;p&gt;这题是第一层，因为只能买卖一次，维护一个全局最小值和一个全局最大值就好，最后返回一个全局最优解即可。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int maxProfit(int[] prices) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(prices.length == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int minmoney = prices[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int maxmonty = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 1; i &amp;lt; prices.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(prices[i] - minmoney &amp;gt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(prices[i] - minmoney &amp;gt; maxmonty)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    maxmonty = prices[i] - minmoney;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(prices[i] &amp;lt; minmoney)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                minmoney = prices[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return maxmonty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;level-2&quot;&gt;&lt;a href=&quot;#level-2&quot; class=&quot;headerlink&quot; title=&quot;level 2&quot;&gt;&lt;/a&gt;level 2&lt;/h1&gt;&lt;h2 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-II&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-II&quot; class=&quot;headerlink&quot; title=&quot;122. Best Time to Buy and Sell Stock II&quot;&gt;&lt;/a&gt;122. Best Time to Buy and Sell Stock II&lt;/h2&gt;&lt;p&gt;这题也是比较简单的，因为可以随买随卖，所以只要后一天的价格比前一天的高，就卖就好，我觉得比 level I 还简单。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int maxProfit(int[] prices) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int total = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; prices.length - 1; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(prices[i+1] - prices[i] &amp;gt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                total += (prices[i+1] - prices[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return total;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;level-3&quot;&gt;&lt;a href=&quot;#level-3&quot; class=&quot;headerlink&quot; title=&quot;level 3&quot;&gt;&lt;/a&gt;level 3&lt;/h1&gt;&lt;h2 id=&quot;122-Best-Time-to-Buy-and-Sell-Stock-III&quot;&gt;&lt;a href=&quot;#122-Best-Time-to-Buy-and-Sell-Stock-III&quot; class=&quot;headerlink&quot; title=&quot;122. Best Time to Buy and Sell Stock III&quot;&gt;&lt;/a&gt;122. Best Time to Buy and Sell Stock III&lt;/h2&gt;&lt;p&gt;这题还是需要技巧的，因为只能够买卖两次，而且买另一个之前需要卖掉前一个。所以这题我们没办法只用O(1)的空间了。这题而且需要两个数组，一个数组表示前一个 stock 买卖的情况，另一个数组表示后一个 stock 买卖的情况。最后再遍历两个数组，求两个数组相加后最大 profit。&lt;/p&gt;
&lt;p&gt;第一个数组就和 level I 一样，把当前的全局最优解放到对应下标的数组就好。&lt;/p&gt;
&lt;p&gt;第二个数组注意下标，因为进行的第二次交易，所以我们要从后往前遍历，记录下全局最大的 price 和到当前坐标下的全局最优解。&lt;/p&gt;
&lt;p&gt;最后遍历两个数组，每一个下标的结果都加起来即可。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @author zhengyu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * @date 2016年1月24日&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // TODO Auto-generated method stub&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] test = &amp;#123;1,2,4&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] test2 = &amp;#123;4,6,3,5,6,7,8,3,4,5,3,5,6,2,5,8&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(maxProfit(test));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(maxProfit(test2));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static int maxProfit(int[] prices) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(prices.length == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int len = prices.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] first = new int[len];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] second = new int[len];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int minprofit = prices[0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int maxprofit = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 1; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxprofit = Math.max(maxprofit, prices[i] - minprofit);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            first[i] = maxprofit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minprofit = Math.min(minprofit, prices[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int maxprice = prices[len - 1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        maxprofit = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int index = len - 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = len - 2; i &amp;gt; -1; i--) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxprofit = Math.max(maxprofit, maxprice - prices[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            second[index--] = maxprofit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            maxprice = Math.max(maxprice, prices[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int result = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; len; i++) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result = Math.max(first[i] + second[i], result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;level-4&quot;&gt;&lt;a href=&quot;#level-4&quot; class=&quot;headerlink&quot; title=&quot;level 4&quot;&gt;&lt;/a&gt;level 4&lt;/h1&gt;&lt;h2 id=&quot;188-Best-Time-to-Buy-and-Sell-Stock-IV&quot;&gt;&lt;a href=&quot;#188-Best-Time-to-Buy-and-Sell-Stock-IV&quot; class=&quot;headerlink&quot; title=&quot;188. Best Time to Buy and Sell Stock IV&quot;&gt;&lt;/a&gt;188. Best Time to Buy and Sell Stock IV&lt;/h2&gt;&lt;p&gt;这个应该是这个系列最难的题目了。还是前面的条件，但是这次能买卖多少次是用户自己输入的。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;level-1&quot;&gt;&lt;a href=&quot;#level-1&quot; class=&quot;headerlink&quot; title=&quot;level 1&quot;&gt;&lt;/a&gt;level 1&lt;/h1&gt;&lt;h2 id=&quot;121-Best-Time-to-Buy-and-Sell-Stock&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(VIII) Topological sort --- 拓扑排序总结</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/13/%E6%80%BB%E7%BB%93(VIII)%20Topological%20sort/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/13/总结(VIII) Topological sort/</id>
    <published>2016-01-13T14:22:30.000Z</published>
    <updated>2016-04-02T05:03:05.000Z</updated>
    
    <content type="html">&lt;p&gt;今天终于把拓扑排序好好的看了一遍，终于稍微搞懂了。其实还是比较简单的。我们只要明白一点：拓扑排序只能作用在有向无环图之中。明白了这个，我们的题目就比较好做了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先是有向无环图，这里我就直接摘抄网上一个写的比较好的例子来说明。&lt;/p&gt;
&lt;p&gt;拓扑排序其实就是有向无环图的所有顶点的线性序列。且该序列必须满足下面两个条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个顶点出现且只出现一次。&lt;/li&gt;
&lt;li&gt;若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，我们就可以开始进行拓扑排序了，我们可以参照下面的步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。&lt;/li&gt;
&lt;li&gt;从图中删除该顶点和所有以它为起点的有向边。&lt;/li&gt;
&lt;li&gt;重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。&lt;br&gt;“下面是图示：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个普通的有向无环图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150507001028284&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面是拓扑排序的步骤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20150507001759702&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后我们可以得到其中一个结果（结果不唯一）：&lt;br&gt; { 1, 2, 4, 3, 5 }&lt;/p&gt;
&lt;h3 id=&quot;leetcode-例子&quot;&gt;&lt;a href=&quot;#leetcode-例子&quot; class=&quot;headerlink&quot; title=&quot;leetcode 例子&quot;&gt;&lt;/a&gt;leetcode 例子&lt;/h3&gt;&lt;h3 id=&quot;207-Course-Schedule&quot;&gt;&lt;a href=&quot;#207-Course-Schedule&quot; class=&quot;headerlink&quot; title=&quot;207. Course Schedule&quot;&gt;&lt;/a&gt;207. Course Schedule&lt;/h3&gt;&lt;p&gt;There are a total of n courses you have to take, labeled from 0 to n - 1.&lt;/p&gt;
&lt;p&gt;Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]&lt;/p&gt;
&lt;p&gt;Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2, [[1,0]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2, [[1,0],[0,1]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean canFinish(int numCourses, int[][] prerequisites) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 用邻接矩阵来储存有向图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[][] matrix = new int[numCourses][numCourses];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] inarray = new int[numCourses];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 建立矩阵，若pre点到current点有边，则设为1，同时current点的入度+1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; prerequisites.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int pre = prerequisites[i][1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int current = prerequisites[i][0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(matrix[pre][current] == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                inarray[current]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            matrix[pre][current] = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 先把入度为0的点加入队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        LinkedList&amp;lt;Integer&amp;gt; que = new LinkedList&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; inarray.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(inarray[i] == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                que.add(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int count = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(que.size() != 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int current = que.poll();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for(int i = 0; i &amp;lt; numCourses; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(matrix[current][i] != 0) &amp;#123; // 判断入度为0的课到该课程上是否有边&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    inarray[i]--;   // 删除该边&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    if(inarray[i] == 0) // 如果该点入度也为0了，加入队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        que.add(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 如果该图是一个有向无环图，则最后拓扑排序一定能遍历所有点，否则不是。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return count == numCourses;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;今天终于把拓扑排序好好的看了一遍，终于稍微搞懂了。其实还是比较简单的。我们只要明白一点：拓扑排序只能作用在有向无环图之中。明白了这个，我们的题目就比较好做了。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(VI) dynamic-programming review --- 动态规划题目总结</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/07/%E6%80%BB%E7%BB%93(VI)%20dynamic-programming%20review/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/07/总结(VI) dynamic-programming review/</id>
    <published>2016-01-07T14:22:30.000Z</published>
    <updated>2016-04-02T04:57:58.000Z</updated>
    
    <content type="html">&lt;p&gt;动态规划的题目，一般可以在网上搜索&lt;strong&gt;&lt;em&gt;《背包九讲》&lt;/em&gt;&lt;/strong&gt;这个帖子，讲的还是挺好的，由浅入深。下面就把自己觉得遇到的比较典型的题目记录下来。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Coin-Change&quot;&gt;&lt;a href=&quot;#1-Coin-Change&quot; class=&quot;headerlink&quot; title=&quot;1. Coin Change&quot;&gt;&lt;/a&gt;1. Coin Change&lt;/h3&gt;&lt;p&gt;You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;coins = [1, 2, 5], amount = 11&lt;br&gt;return 3 (11 = 5 + 5 + 1)&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;coins = [2], amount = 3&lt;br&gt;return -1.&lt;/p&gt;
&lt;p&gt;这个题目就是凑硬币。一开始我没往动态规划上面想。我就觉得每次取最大，不行就倒退。后来发现这个想法不现实。还是只能一个一个求出来，然后由下往上求解。&lt;/p&gt;
&lt;p&gt;####code[java] 非递归&lt;/p&gt;
&lt;p&gt;基本就是bottom-up的解法。先凑1元，得出凑出1元最少需要多少个，然后求2元……以此类推，到求出amount。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int coinChange(int[] coins, int amount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(amount == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] result = new int[amount + 1];        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int sum = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(++sum &amp;lt;= amount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int min = -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for(int i = 0; i &amp;lt; coins.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(sum &amp;gt;= coins[i] &amp;amp;&amp;amp; result[sum - coins[i]] != -1) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    int t = result[sum - coins[i]] + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    if(min &amp;lt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        min = result[sum - coins[i]] + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        if(result[sum - coins[i]] + 1 &amp;lt; min)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            min = result[sum - coins[i]] + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result[sum] = min;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result[amount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;####code[java] 递归&lt;/p&gt;
&lt;p&gt;和非递归差不多，不过是由up到bottom。假设当前我们已经能得到当前的钱数，那么，遍历一遍coin，看前一个能凑成当前钱数最小的，那么当前的最小组合数就是lastsum+1。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public int coinChange(int[] coins, int amount) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (amount &amp;lt; 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return helper(coins, amount, new int[amount]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private int helper(int[] coins, int rem, int[] count) &amp;#123; // rem: remaining&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;															// coins after the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;															// last step;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;															// count[rem]:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;															// minimum number of&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;															// coins to sum up&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;															// to rem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (rem &amp;lt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return -1; // not valid&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (rem == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return 0; // completed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (count[rem - 1] != 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return count[rem - 1]; // already computed, so reuse&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		int min = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		for (int coin : coins) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			int res = helper(coins, rem - coin, count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if (res &amp;gt;= 0 &amp;amp;&amp;amp; res &amp;lt; min)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				min = 1 + res;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return count[rem - 1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;动态规划的题目，一般可以在网上搜索&lt;strong&gt;&lt;em&gt;《背包九讲》&lt;/em&gt;&lt;/strong&gt;这个帖子，讲的还是挺好的，由浅入深。下面就把自己觉得遇到的比较典型的题目记录下来。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(VII) Design review --- 设计题目总结</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/07/%E6%80%BB%E7%BB%93(VII)%20Design%20review/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/07/总结(VII) Design review/</id>
    <published>2016-01-07T14:22:30.000Z</published>
    <updated>2016-04-02T05:03:48.000Z</updated>
    
    <content type="html">&lt;p&gt;基本上看到哪里就记到哪里吧，看到高频的就记一下。&lt;/p&gt;
&lt;h3 id=&quot;洗牌算法&quot;&gt;&lt;a href=&quot;#洗牌算法&quot; class=&quot;headerlink&quot; title=&quot;洗牌算法&quot;&gt;&lt;/a&gt;洗牌算法&lt;/h3&gt;&lt;p&gt;这个有意思了，以前重来没想过这个问题。有些公司会问你怎么去设计ipod，然后重点问你怎么去设计随机播放。尽可能有少的资源，而且不会有重复的。当然，简单地调用ramdon估计就是回被提出去的了。然后在网上看到一个简单的解法，先记下，有空再去深究：&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Shuffle &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String arg[])&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String[] musicUrl=&amp;#123;&amp;quot;/music/1.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/2.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/3.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/4.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/5.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/6.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/7.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/8.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/9.mp3&amp;quot;,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;quot;/music/10.mp3&amp;quot;&amp;#125;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        shuffle(musicUrl);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(String music:musicUrl)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(music);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void shuffle(String[] musicUrl)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int shuffle_key;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String temp;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Random rand = new Random();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; musicUrl.length; i++)&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            shuffle_key = rand.nextInt(musicUrl.length-1);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            temp = musicUrl[i];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            musicUrl[i] = musicUrl[shuffle_key];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            musicUrl[shuffle_key] = temp;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Tri-字典树和回溯法结合的题目-–-leetcode-211-Add-and-Search-Word-Data-structure-design&quot;&gt;&lt;a href=&quot;#Tri-字典树和回溯法结合的题目-–-leetcode-211-Add-and-Search-Word-Data-structure-design&quot; class=&quot;headerlink&quot; title=&quot;Tri 字典树和回溯法结合的题目 – leetcode 211. Add and Search Word - Data structure design&quot;&gt;&lt;/a&gt;Tri 字典树和回溯法结合的题目 – leetcode 211. Add and Search Word - Data structure design&lt;/h3&gt;&lt;p&gt;这题过了，基本上可以说自己应该稍微掌握了字典树和回溯法了。当然，其实这两个并不难，只要我们仔细想好每一个步骤就好。其实回溯法和暴力比较像，不过要注意边角条件就是了。&lt;/p&gt;
&lt;p&gt;字典树还是比较好理解的，如果有一些单词有了共同前缀，我们就省略一些空间来存储这些数据，而是去主要存储后缀就好。而字典树的内部可以用map或者数组都可以，看大家自己喜欢，我的字典树是用26位数组存的，稍微浪费了一点空间。&lt;/p&gt;
&lt;p&gt;下面是字典树的具体实现：&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class TrieNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Initialize your data structure here.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    boolean isWord;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    char val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TrieNode[] ChildNode = new TrieNode[26];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public TrieNode() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public TrieNode(char c) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TrieNode n = new TrieNode();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n.val = c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Trie &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private TrieNode root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Trie() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root = new TrieNode();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root.val = &amp;apos; &amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Inserts a word into the trie.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void insert(String word) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TrieNode p = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; word.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            char c = word.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(p.ChildNode[c - &amp;apos;a&amp;apos;] == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                p.ChildNode[c - &amp;apos;a&amp;apos;] = new TrieNode(c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p.ChildNode[c - &amp;apos;a&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p.isWord = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Returns if the word is in the trie.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean search(String word) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TrieNode p = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; word.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            char c = word.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(p.ChildNode[c - &amp;apos;a&amp;apos;] == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p.ChildNode[c - &amp;apos;a&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return p.isWord;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Returns if there is any word in the trie&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // that starts with the given prefix.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean startsWith(String prefix) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TrieNode p = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; prefix.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            char c = prefix.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(p.ChildNode[c - &amp;apos;a&amp;apos;] == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            p = p.ChildNode[c - &amp;apos;a&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在搜索是否存在一个单词的时候，有点像链表的便利。注意我们的字典树中存储了一个boolean变量，其实这个变量就是为了判断这个字母结尾的时候，是不是构成一个单词。&lt;/p&gt;
&lt;p&gt;按照上面的例子，我自己又实现了一下leetcode的211题目，然后搜索的时候用了回溯法，一次通过了。下面给出自己的解法。其实还是按照回溯法之前的套路，用一个help函数来帮组我们。如果遇到了”.”, 我们就把26个字母都要扫一遍，只要有一个遍历是跑通的，我们就说明存在这个函数。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class WordDictionary &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public class Node &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public Node[] carray;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public boolean iscorrent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public char c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        public Node(char c) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            this.c = c;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            carray = new Node[26];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            iscorrent = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Node root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public WordDictionary() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root = new Node(&amp;apos; &amp;apos;); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Adds a word into the data structure.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void addWord(String word) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node current = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; word.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(current.carray[word.charAt(i) - &amp;apos;a&amp;apos;] == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                current.carray[word.charAt(i) - &amp;apos;a&amp;apos;] = new Node(word.charAt(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            current = current.carray[word.charAt(i) - &amp;apos;a&amp;apos;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current.iscorrent = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Returns if the word is in the data structure. A word could&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // contain the dot character &amp;apos;.&amp;apos; to represent any one letter.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean search(String word) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Node current = root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int index = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        boolean result = help(current, word, index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean help(Node temp, String word, int index) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(temp == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(word.length() == index)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return temp.iscorrent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        char c = word.charAt(index);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(c == &amp;apos;.&amp;apos;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            boolean tempresult = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for(int i = 0; i &amp;lt; 26; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                tempresult |= help(temp.carray[i], word, index + 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return tempresult;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(temp.carray[c - &amp;apos;a&amp;apos;] == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return help(temp.carray[c - &amp;apos;a&amp;apos;], word, index + 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param args&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // TODO Auto-generated method stub&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        WordDictionary wordDictionary = new WordDictionary();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        wordDictionary.addWord(&amp;quot;word&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(wordDictionary.search(&amp;quot;patter&amp;quot;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;OK&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(&amp;quot;ERROR&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Suppose-you-have-a-logger-class-that-is-used-to-log-error-and-warning-messages-How-can-you-implement-this-class-while-using-the-Singleton-design-pattern&quot;&gt;&lt;a href=&quot;#Suppose-you-have-a-logger-class-that-is-used-to-log-error-and-warning-messages-How-can-you-implement-this-class-while-using-the-Singleton-design-pattern&quot; class=&quot;headerlink&quot; title=&quot;Suppose you have a logger class that is used to log error and warning messages. How can you implement this class while using the Singleton design pattern?&quot;&gt;&lt;/a&gt;Suppose you have a logger class that is used to log error and warning messages. How can you implement this class while using the Singleton design pattern?&lt;/h3&gt;&lt;p&gt;这题也是考察基本的Singleton方法。既然我们只能产生一个实例，那么，只能够将构造函数设为privete. 换句话说,外部是没办法通过构造函数创建实例.所以,我们只会产生一个实例在类的内部当中.&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// Implements a simple logging class using a singleton.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Logging &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // this creates the actual Singleton instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private static final Logging singletonInstance = new Logging();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Private constructor prevents others from instantiating this class:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Logging() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // this method returns the singleton instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static Logging getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return singletonInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * This will print a message to the screen: sample call:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * Logging.getSingleton().log(&amp;quot;testing message&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void log(String message) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(System.currentTimeMillis() + &amp;quot;: &amp;quot; + message);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;基本上看到哪里就记到哪里吧，看到高频的就记一下。&lt;/p&gt;
&lt;h3 id=&quot;洗牌算法&quot;&gt;&lt;a href=&quot;#洗牌算法&quot; class=&quot;headerlink&quot; title=&quot;洗牌算法&quot;&gt;&lt;/a&gt;洗牌算法&lt;/h3&gt;&lt;p&gt;这个有意思了，以前重来没想过这个问题。有些公司会问你怎么去设
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="设计" scheme="http://yu-zhengyu.github.com/note/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>总结(V) List review --- List 题目总结</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/06/%E6%80%BB%E7%BB%93(V)%20List%20review/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/06/总结(V) List review/</id>
    <published>2016-01-06T14:22:30.000Z</published>
    <updated>2016-04-02T05:03:57.000Z</updated>
    
    <content type="html">&lt;p&gt;List的题目可以说是我做的最不好的。并不是说不会方法，而是有时候边界条件的检查让我们可能很难在15分钟之内做到bug free。所以我这里举出一些常用的手法，到时候大家可以直接背下来，直接用。当然你也可以现场画图，但是我觉得那样时间就慢了。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Reverse-a-list-in-place&quot;&gt;&lt;a href=&quot;#1-Reverse-a-list-in-place&quot; class=&quot;headerlink&quot; title=&quot;1. Reverse a list in place&quot;&gt;&lt;/a&gt;1. Reverse a list in place&lt;/h3&gt;&lt;p&gt;不用多余的空间，翻转一个链表，这个其实一开始我是觉得挺有难度的，因为每次我都记不住，所以我这次就直接记下了，免得到时候用着又来查。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public ListNode reverseList(ListNode head) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(head==null) return head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode temp1= head.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode temp2= null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    head.next=null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(temp1!=null)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp2=temp1.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp1.next=head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        head=temp1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp1=temp2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;2-find-the-middle-of-linked-list&quot;&gt;&lt;a href=&quot;#2-find-the-middle-of-linked-list&quot; class=&quot;headerlink&quot; title=&quot;2. find the middle of linked list&quot;&gt;&lt;/a&gt;2. find the middle of linked list&lt;/h3&gt;&lt;p&gt;高频率用到，主要的方法就是用一个runner指针。这个技巧也会用在寻找一个链表中是否有回路。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static ListNode getMiddleOfList(ListNode l) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ListNode fast = l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ListNode slow = l;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	ListNode prev = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	while(fast != null &amp;amp;&amp;amp; fast.next != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		prev = slow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		slow = slow.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		fast = fast.next.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return slow;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码基本包含了奇偶的情况，有这种题就大胆往上写，绝对不出错。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;3-reverse-a-list-from-m-to-n&quot;&gt;&lt;a href=&quot;#3-reverse-a-list-from-m-to-n&quot; class=&quot;headerlink&quot; title=&quot;3. reverse a list from m to n&quot;&gt;&lt;/a&gt;3. reverse a list from m to n&lt;/h3&gt;&lt;p&gt;这题我做的真的不好，后来还是看答案来写了。一开始的思路不太好。总认为是要先把 m 到 n 的链表先翻转了，然后再将这个翻转后的链表连回原来的头和尾。这样导致了我总是没办法满足一些边界条件。&lt;/p&gt;
&lt;p&gt;其实这题不需要我想的那么麻烦，其实就记得一个头，然后每次遍历以后把当前的node插入到头的下一个就好了。这样的话还不容易出错。还有就是dummy的技巧用的不是很熟，以后打算每天都写一遍这个题，加强手部反应。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Definition for singly-linked list.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * public class ListNode &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     ListNode next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; *     ListNode(int x) &amp;#123; val = x; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public ListNode reverseBetween(ListNode head, int m, int n) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(head == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode dummy = new ListNode(0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dummy.next = head;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode pre = dummy;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; m - 1; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pre = pre.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode current = pre.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ListNode nextn = current.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; n - m; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            current.next = nextn.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nextn.next = pre.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            pre.next = nextn;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            nextn = current.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return dummy.next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;List的题目可以说是我做的最不好的。并不是说不会方法，而是有时候边界条件的检查让我们可能很难在15分钟之内做到bug free。所以我这里举出一些常用的手法，到时候大家可以直接背下来，直接用。当然你也可以现场画图，但是我觉得那样时间就慢了。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(IX) Java Interview --- java面试二三事</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/06/%E6%80%BB%E7%BB%93(IX)%20Java%20Interview/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/06/总结(IX) Java Interview/</id>
    <published>2016-01-06T14:22:30.000Z</published>
    <updated>2016-04-02T05:04:11.000Z</updated>
    
    <content type="html">&lt;p&gt;自己本来是个python的程序员,然而来了CMU后都被带成java程序员了,没办法了,现在面试也以Java为主,不过其实各个语言也是相通的.那么接下来我就收集一些JAVA面试时候会问的奇奇怪怪的问题吧.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;##[基础知识篇]&lt;/p&gt;
&lt;p&gt;#####1. 什么是JVM&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;JVM 就是java虚拟机.JVM 会把Java code编译为byte code, 然后执行这些byte code.所有系统都能够安装JAVA虚拟机,这也体现了Java程序的多平台执行优势.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####2. OOPS 的重要概念.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OOPS就是面向对象编程,主要包括以下4个概念:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. Abstraction 抽象性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. Polymorphism 多态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. Inheritance 继承&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. Encapsulation 封装&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####3. Overloadding VS Overriding&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Overloadding 发生在compile阶段,Overriding 发生在runtime阶段.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Overloading是在同一个类中写同一个函数,只是参数的类型不同.而overriding一般会在子类中出现,并且重写的时候函数名字和参数类型是一样的.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 返回类型,overloading 是可以自由定义,但是Overriding就必须和继承的父类保持一致.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 你可以overloading一个static 类, 但是不能overriding一个static类.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####4. static VS instance&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static method是一个类级别的方法,你可以直接调用它.但是instance方法是一个对象级别的方法,你必须首先创建一个引用指向它,然后再进行调用.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####5. Stringbuilder, Stringbuffer, string 的区别&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* String是immutable,不可改变的.Stringbuilder 和 Stringbuffer 都是mutable的.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Stringbuffer 是 synchronized,Stringbuilder 不是&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Stringbuilder 比 Stringbuffer 快.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* StringBuffer线程安全,且保证同步.Stringbuilder不保证线程同步.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* String也是线程安全的,因为它不能够改变.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####6. Java是值传递还是引用传递&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;当写函数的过程中,如果参数是基本类,如int或者double,那么我们会发现java是值传递.但是,在Java中对象作为参数传递时,是把对象在内存中的地址拷贝了一份传给了参数.所以,总体来说,都是pass by value.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####7. Searialziation 和 Desearialziation.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Searialziation 是将对象转化为数据流,方便对象能够在网络中进行传递.Desearialziation当然就是讲流转为对象了.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####8. final, finally, and finalize&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Final 能够修饰变量,方法和类.修饰变量,说明该变量不能再改变.修饰method,说明该方法不能被overridden.修饰class说明该类不能够被继承.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* finally是用在异常处理的情况.代码如果被写入了finally的块中,不管该段代码是否抛出异常,到最后finally块中的代码都必须执行.这个修饰一般用在关闭网络流,数据库或者输入输出流一类的处理.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* finalize是用在垃圾回收的过程.finalize会被垃圾回收调用,会在对象被抛弃之前清理所有的活动.java提供finalize()方法,垃圾回收器准备释放内存的时候,会先调用finalize().&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#####9. java如何创建多线程&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;一般在java中,创建多线程有两种方法:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 继承Thread类;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重写run() 函数,然后调用start()函数.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class simpleThread extends Thread &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		// 写上你的task&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;Hello&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class simple &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] agrs) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		simpleThread t = new simpleThread();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 实现Runnable接口.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;方法和上面差不多,不过是实现接口,重写的函数还是run方法.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class simpleThread implements Runnable &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public void run() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		// 写上你的task&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&amp;quot;Hello&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class simple &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] agrs) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Thread t = new Thread( new simpleThread() );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		t.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&quot;10-java-HashMap-有什么特点&quot;&gt;&lt;a href=&quot;#10-java-HashMap-有什么特点&quot; class=&quot;headerlink&quot; title=&quot;10. java HashMap, 有什么特点&quot;&gt;&lt;/a&gt;10. java HashMap, 有什么特点&lt;/h5&gt;&lt;p&gt;是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。&lt;/p&gt;
&lt;h5 id=&quot;11-HashMap-的-get-和-put-函数是如何工作的&quot;&gt;&lt;a href=&quot;#11-HashMap-的-get-和-put-函数是如何工作的&quot; class=&quot;headerlink&quot; title=&quot;11. HashMap 的 get 和 put 函数是如何工作的&quot;&gt;&lt;/a&gt;11. HashMap 的 get 和 put 函数是如何工作的&lt;/h5&gt;&lt;p&gt;当我们使用 put 函数的时候，我们会把 Key 和 value 传入，hashmap 会使用 hashcood 函数计算出 key 的哈希值，通过计算出的哈希值找到对应的 bucket，如果当前的 bucket 已经满了，HashMap会根据情况对容量进行扩容，一般是当前 capacity 的两倍。使用 get 函数的时候，传入 key 的值，计算出对应的哈希值，找到相应的 bucket，然后在 bucket 中使用 equals 函数找到相应的key。如果出现碰撞的情况，一般会使用链表来解决冲突。&lt;/p&gt;
&lt;h5 id=&quot;12-Hashcode-函数一般是怎么计算的&quot;&gt;&lt;a href=&quot;#12-Hashcode-函数一般是怎么计算的&quot; class=&quot;headerlink&quot; title=&quot;12. Hashcode 函数一般是怎么计算的&quot;&gt;&lt;/a&gt;12. Hashcode 函数一般是怎么计算的&lt;/h5&gt;&lt;p&gt;在 java1.8中，一般是将key 的高16位异或上低16位获得的。&lt;/p&gt;
&lt;h5 id=&quot;13-为什么要创建私有的构造函数&quot;&gt;&lt;a href=&quot;#13-为什么要创建私有的构造函数&quot; class=&quot;headerlink&quot; title=&quot;13. 为什么要创建私有的构造函数&quot;&gt;&lt;/a&gt;13. 为什么要创建私有的构造函数&lt;/h5&gt;&lt;p&gt;私有构造函数和一般的私有函数没有区别，也是只能够类内部进行调用，外部无法进行访问。创建私有构造函数的原因可能有两个：一，是你不想让除类之外的其他类构造这个类。二是你只希望该对象在类的内部构造。&lt;/p&gt;
&lt;p&gt;另外，私有构造函数一般用在singleton design pattern中。这也是开发人员使用私有构造函数的又一个原因。&lt;/p&gt;
&lt;h6 id=&quot;关于-singleton-design&quot;&gt;&lt;a href=&quot;#关于-singleton-design&quot; class=&quot;headerlink&quot; title=&quot;关于 singleton design&quot;&gt;&lt;/a&gt;关于 singleton design&lt;/h6&gt;&lt;p&gt;设计 singleton 的关键就是不能让其他类随便构造该类对象。那么，我们唯一能做的就是控制该类的构造函数。将构造函数变为私有是一个关键的步骤。 下面是一个 singleton 设计的例子。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 以 singleton 的模式实现该类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Logging &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 创建一个实例，有且只有一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private static final Logging singletonInstance = new Logging();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 私有构造函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	private Logging() &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 返回实例，保证了有且只有一个实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static Logging getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return singletonInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h6 id=&quot;假设我们希望上面的-singleton-实例只有在被需要的时候再创建从而节省一些资源，我们应该怎么做。&quot;&gt;&lt;a href=&quot;#假设我们希望上面的-singleton-实例只有在被需要的时候再创建从而节省一些资源，我们应该怎么做。&quot; class=&quot;headerlink&quot; title=&quot;假设我们希望上面的 singleton 实例只有在被需要的时候再创建从而节省一些资源，我们应该怎么做。&quot;&gt;&lt;/a&gt;假设我们希望上面的 singleton 实例只有在被需要的时候再创建从而节省一些资源，我们应该怎么做。&lt;/h6&gt;&lt;p&gt;这题还是承接上面的题目来说的。其实只要对 getSingleton 函数稍微修改一下即可&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static Logging singletonInstance = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static Logging getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if(singletonInstance == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		singletonInstance = new Loging();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	reutrn singletonInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h6 id=&quot;在设计-singleton-的时候，如何保证线程安全？？&quot;&gt;&lt;a href=&quot;#在设计-singleton-的时候，如何保证线程安全？？&quot; class=&quot;headerlink&quot; title=&quot;在设计 singleton 的时候，如何保证线程安全？？&quot;&gt;&lt;/a&gt;在设计 singleton 的时候，如何保证线程安全？？&lt;/h6&gt;&lt;p&gt;这个题也是承接上面的两个问题的。首先明白，为什么要保证线程安全。首先，上面的例子, 我们这样看视乎并没有什么问题。这是因为都是基于单线程来看的。假设我们现在有多个线程，并且这些线程同时调用上面的 getsingleton 函数来对实例进行初始化，因为同一时间满足了条件，结果我们也创建了两个或以上的实例。那么怎么解决这个问题。其实，java 也已经替我们想好了，只要在函数前面加上 synchronized 的关键字就可以了。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;private static Logging singletonInstance = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public synchronized static Logging getSingleton() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if(singletonInstance == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		singletonInstance = new Loging();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	reutrn singletonInstance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;synchronized 会保证该函数只有一个线程能够进行访问，从而避免了上述冲突情况的出现。&lt;/p&gt;
&lt;h5 id=&quot;14-finally-中的代码会在-return-之后执行么？&quot;&gt;&lt;a href=&quot;#14-finally-中的代码会在-return-之后执行么？&quot; class=&quot;headerlink&quot; title=&quot;14. finally 中的代码会在 return 之后执行么？&quot;&gt;&lt;/a&gt;14. finally 中的代码会在 return 之后执行么？&lt;/h5&gt;&lt;p&gt;这个题目也是有趣。一般来说，一个函数如果调用了 return，基本上说明该函数已经停止了，在这之后的代码也不会执行，编译器其实也会提示错误，然而下面的例子能够说明一些问题：&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class SomeClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String args[]) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // call the proveIt method and print the return value&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	System.out.println(SomeClass.proveIt()); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static int proveIt()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	try &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            	return 1;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	finally &amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	    System.out.println(&amp;quot;finally block is run &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            before method returns.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后，该段代码的输出为&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;finally block is run before method returns.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们发现了，return 后的代码不但执行了，还是在 return 之前。&lt;/p&gt;
&lt;p&gt;‘’‘当然有例外，假如是调用 System.exit(), 那么final 块的代码就不会调用’‘’&lt;/p&gt;
&lt;p&gt;##[code 篇]&lt;/p&gt;
&lt;h3 id=&quot;用最少的code写一个函数-要求会把栈用光&quot;&gt;&lt;a href=&quot;#用最少的code写一个函数-要求会把栈用光&quot; class=&quot;headerlink&quot; title=&quot;用最少的code写一个函数,要求会把栈用光.&quot;&gt;&lt;/a&gt;用最少的code写一个函数,要求会把栈用光.&lt;/h3&gt;&lt;p&gt;当时第一次遇到这种问题,我本身吓了一跳.不过其实这题是考你基础知识,就是栈和堆的问题.一般来收,所有的对象都是存放到堆中的,而指向对象的reference是存在栈里面的,函数调用,一开始也会放进栈.那么,用光栈最快的方法就是进行递归调用.下面上代码&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Useupstack &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		help();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static help() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		help();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;follow-up-如果是用完堆里面的函数呢？？&quot;&gt;&lt;a href=&quot;#follow-up-如果是用完堆里面的函数呢？？&quot; class=&quot;headerlink&quot; title=&quot;follow up: 如果是用完堆里面的函数呢？？&quot;&gt;&lt;/a&gt;follow up: 如果是用完堆里面的函数呢？？&lt;/h4&gt;&lt;p&gt;这个也是基础知识的考察,那么,因为java里面不方便对内存直接调用,所以这里我们用C++来进行解答.&lt;br&gt;我们知道,C++可以任意对内存进行控制,那么我们就可以用C++的malloc函数来进行内存操作.&lt;/p&gt;
&lt;p&gt;####code[C++]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void main(int argc, char** argv)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        malloc(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;自己本来是个python的程序员,然而来了CMU后都被带成java程序员了,没办法了,现在面试也以Java为主,不过其实各个语言也是相通的.那么接下来我就收集一些JAVA面试时候会问的奇奇怪怪的问题吧.&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>关于仙剑奇侠传6的一些感想</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/05/%E5%85%B3%E4%BA%8E%E4%BB%99%E5%89%91%E5%A5%87%E4%BE%A0%E4%BC%A06%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/05/关于仙剑奇侠传6的一些感想/</id>
    <published>2016-01-05T07:23:10.000Z</published>
    <updated>2016-04-01T23:20:27.000Z</updated>
    
    <content type="html">&lt;p&gt;&lt;strong&gt;&lt;em&gt;仙剑&lt;/em&gt;&lt;/strong&gt; 这个IP真的陪了自己好多年，记得第一次玩这个游戏的时候还是小学一年级。那个时候，我连那个苗族头领都卡了N久（估计很多人第一次也是被这里卡了很久对吧）。没想到一晃神，仙剑都已经陪了自己那么久了。一开始其实没有打算再继续碰这个续作，本来准备就直接在网上看别人视频直播补一下剧情就好了。但是当看到进度的大概20%的时候，我真的忍不住还是买了一套自己玩（虽然后来玩到一半，因为出国了，电脑换了Mac，没办法继续玩，还是在YouTube上看了别人录制的视频，包括DLC剧情）。说真的，我是个剧情控，一个RPG好不好，剧情是摆在首位的，尤其是国产RPG在画面，技术和经验都不如日本和美国的情况下，我觉得剧情是国产RPG必须死守的阵地。写到这，看官们应该懂得我的意思了，“这次仙剑的剧情是达到了水准的”。一个游戏下来，能让我记得的情节非常多：越今朝和越祈遭遇伏击，第一次分开（也是看到这里决定入手仙剑6）；扁络桓和越今朝那一段穿越，最后传承下去的情节；越祈因为今朝死去而一个人独自吃面的情节。这三个是我到现在还很清楚印在脑海里的情节。我不知道为什么当时网络上指责《仙剑6》抄袭《罪恶王冠》，然后还列举了一大堆证据来证明。我看过了那些文章的分析，如果没有看过和玩过这两个作品的，估计就会相信了。但是，《罪恶王冠》我看了3遍，《仙剑6》虽然也就过了这一遍，说真的，很难找到抄袭的痕迹。如果真的硬要掰说什么名字一样，从祈身体拔剑的情节一样之类的，我也无话可说。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;过了一周目的剧情后，那种以前内心空虚的感觉又涌上了心头。就是那种希望RPG游戏的故事还有后序的那种感情，我相信很多看小说和喜爱RPG的玩家们都有过那种感觉。不是每个作品都是做到的，尤其是当我们长大后，看过的作品越来越多，有些手法读者和玩家搞不好比作者还娴熟，一般就是看到了开头，就猜到结尾的那种。（像《星际穿越》一样，我当时真心一看开头就猜到了结尾，也大概猜出了想讲啥，估计这就是看过太多作品的后遗症了吧。）尤其是现在，大家的胃口早就被好作品给提升了，要创作一些新的东西给大家惊喜的感觉，确实不容易。虽说穿越这种“老梗”也被玩过很多次，但是这一次也是给出了不一样的感觉，我很喜欢那一段，我觉得整个故事的小高潮就是扁络桓换越今朝那里，当回到正常的时候后，扁络桓一切存在都不复存在，当时我的心就像被掏空了一样。&lt;/p&gt;
&lt;p&gt;当然，情节上不能说是100%的完美，瑕疵还是存在，有些地方我其实到现在还是没有搞懂，比如这衡道众是从哪冒出来的，“病残弱小”的过去，“藏锋”这角色我觉得有点不明不白等等。估计后面的DCL会有吧。&lt;/p&gt;
&lt;p&gt;还是就是，通过这个游戏，我更正了自己的一些观点。记得我表妹在入职网易游戏前问过我，说公司给他们两个方向去培养，一个是美术，一个是音乐。我当时毫不犹豫的说当然是美术。一个游戏好不好玩，美术可是至关重要。音乐这个东西，很难给人留下什么印象。&lt;/p&gt;
&lt;p&gt;老实说，现在我还是觉得美术很重要，但是音乐这个东西，我觉得我以前是小瞧了它。下面我帖出了这次仙剑中我最喜欢的一段配乐，就是越今朝主题音乐。很久没试过游戏背景音乐让我循环播放那么多次了。这次的仙剑我觉得在音乐方面也是下了苦功夫。光主题曲就有4首。音乐和画面相比的话，音乐确实能够传承更久。现在我们去玩以前的游戏，那些画面真心没办法顶住。但是，音乐是很让人能够接受的，不管是现在，还是将来，简单的例子，《武林群侠传》和《侠客风云传》，两个游戏配乐几乎没变，但是，我们现在真心没办法忍受《武林》的那种画风，但是，当它的音乐在《侠客》里面再次响起时候，很容易让人再次陷入以前追随江湖小虾米的那种激情当中。&lt;/p&gt;
&lt;p&gt;现在也凌晨3点了，还是早点睡觉。时隔多年首次回来写这些文字，估计错别字和逻辑都有很多错误。以后会多改进。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ximalaya.com/swf/sound/red.swf?id=7833658&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;越今朝主题曲&lt;/a&gt; 有兴趣的可以点进去一听。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;仙剑&lt;/em&gt;&lt;/strong&gt; 这个IP真的陪了自己好多年，记得第一次玩这个游戏的时候还是小学一年级。那个时候，我连那个苗族头领都卡了N久（估计很多人第一次也是被这里卡了很久对吧）。没想到一晃神，仙剑都已经陪了自己那么久了。一开始其实没有打算再继续碰这个续作，本来准备就直接在网上看别人视频直播补一下剧情就好了。但是当看到进度的大概20%的时候，我真的忍不住还是买了一套自己玩（虽然后来玩到一半，因为出国了，电脑换了Mac，没办法继续玩，还是在YouTube上看了别人录制的视频，包括DLC剧情）。说真的，我是个剧情控，一个RPG好不好，剧情是摆在首位的，尤其是国产RPG在画面，技术和经验都不如日本和美国的情况下，我觉得剧情是国产RPG必须死守的阵地。写到这，看官们应该懂得我的意思了，“这次仙剑的剧情是达到了水准的”。一个游戏下来，能让我记得的情节非常多：越今朝和越祈遭遇伏击，第一次分开（也是看到这里决定入手仙剑6）；扁络桓和越今朝那一段穿越，最后传承下去的情节；越祈因为今朝死去而一个人独自吃面的情节。这三个是我到现在还很清楚印在脑海里的情节。我不知道为什么当时网络上指责《仙剑6》抄袭《罪恶王冠》，然后还列举了一大堆证据来证明。我看过了那些文章的分析，如果没有看过和玩过这两个作品的，估计就会相信了。但是，《罪恶王冠》我看了3遍，《仙剑6》虽然也就过了这一遍，说真的，很难找到抄袭的痕迹。如果真的硬要掰说什么名字一样，从祈身体拔剑的情节一样之类的，我也无话可说。&lt;/p&gt;
    
    </summary>
    
      <category term="游戏" scheme="http://yu-zhengyu.github.com/note/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
      <category term="游戏" scheme="http://yu-zhengyu.github.com/note/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>N sum question review --- N sum 题目总结</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/04/N-sum-question-review/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/04/N-sum-question-review/</id>
    <published>2016-01-04T14:22:30.000Z</published>
    <updated>2016-04-02T05:07:16.000Z</updated>
    
    <content type="html">&lt;p&gt;leetcode里面出了一系列的这种题目，分别是two sum，3 sum，3 sum closed，4 sum。 期中出了two sum是利用hashmap外，其他基本的套路都是差不多的，都是先固定一个数字，然后进行左右夹逼的。时间复杂度基本就是O(n^(N-1)), 期中 N 就是指由多少个sum。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-Two-Sum&quot;&gt;&lt;a href=&quot;#1-Two-Sum&quot; class=&quot;headerlink&quot; title=&quot;1. Two Sum&quot;&gt;&lt;/a&gt;1. Two Sum&lt;/h3&gt;&lt;p&gt;用一个哈希表,存储每个数对应的下标，因为这个题目需要返回下标，所以我们之前说的方法，先排序，再固定，后夹逼的方法在这题不太方便。所以还是老实用hash，时间是O(n), 空间是O(n).&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int[] twoSum(int[] nums, int target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        HashMap&amp;lt;Integer, Integer&amp;gt; a = new HashMap&amp;lt;Integer, Integer&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] result = new int[2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; nums.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(a.containsKey(target - nums[i])) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result[0] = a.get(target - nums[i]) + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result[1] = i + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                a.put(nums[i], i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;15-3Sum&quot;&gt;&lt;a href=&quot;#15-3Sum&quot; class=&quot;headerlink&quot; title=&quot;15. 3Sum&quot;&gt;&lt;/a&gt;15. 3Sum&lt;/h3&gt;&lt;p&gt;这题可以用我们所说的那套固定-夹逼的方法了。注意这题需要去掉一些重复的结果。直接上代码了。&lt;/p&gt;
&lt;p&gt;PS: 找数字的时候注意去掉重复的。if-else的条件注意细节。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Arrays.sort(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(nums.length &amp;lt; 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; nums.length - 2; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                continue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int begin = i + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int end = nums.length - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int fix = nums[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(begin &amp;lt; end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(nums[begin] + nums[end] + fix == 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    List&amp;lt;Integer&amp;gt; temp = new ArrayList&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    temp.add(fix);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    temp.add(nums[begin]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    temp.add(nums[end]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    result.add(temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    while(begin &amp;lt; end &amp;amp;&amp;amp; nums[begin] == nums[begin + 1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        begin++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    while(begin &amp;lt; end &amp;amp;&amp;amp; nums[end] == nums[end - 1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        end--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    begin++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    end--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                else if(nums[begin] + nums[end] + fix &amp;lt; 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    begin++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    end--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;16-3Sum-Closest&quot;&gt;&lt;a href=&quot;#16-3Sum-Closest&quot; class=&quot;headerlink&quot; title=&quot;16. 3Sum Closest&quot;&gt;&lt;/a&gt;16. 3Sum Closest&lt;/h3&gt;&lt;p&gt;这题和上一题思路基本一样，改改条件就可以了。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int threeSumClosest(int[] nums, int target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int minDiff = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int result = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Arrays.sort(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int a = 0; a &amp;lt; nums.length - 2; a++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int b = a + 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int c = nums.length - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(b &amp;lt; c) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                int gap = Math.abs(target - (nums[a] + nums[b] + nums[c]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(gap &amp;lt; minDiff) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    minDiff = gap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    result = nums[a] + nums[b] + nums[c];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(nums[a] + nums[b] + nums[c] &amp;lt; target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    b++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    c--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;18-4Sum&quot;&gt;&lt;a href=&quot;#18-4Sum&quot; class=&quot;headerlink&quot; title=&quot;18. 4Sum&quot;&gt;&lt;/a&gt;18. 4Sum&lt;/h3&gt;&lt;p&gt;这题如果用排序加左右夹逼，时间是O(n^3)。有人说会超时，但是我的好像没问题。如果超时的话，可以尝试采用一个hash来做缓冲，每两个数字组成一个pair，这样的预处理就时间是O(n^2), 然后就是和2 sum的做法差不多。我这题没这样写，把别人的代码贴上学习一下：&lt;/p&gt;
&lt;p&gt;####code[C++]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; fourSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (nums.size() &amp;lt; 4) return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(nums.begin(), nums.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        unordered_multimap&amp;lt;int, pair&amp;lt;int, int&amp;gt;&amp;gt; cache;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 0; i + 1 &amp;lt; nums.size(); ++i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for (int j = i + 1; j &amp;lt; nums.size(); ++j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                cache.insert(make_pair(nums[i] + nums[j], make_pair(i, j)));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (auto i = cache.begin(); i != cache.end(); ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int x = target - i-&amp;gt;first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            auto range = cache.equal_range(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for (auto j = range.first; j != range.second; ++j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                auto a = i-&amp;gt;second.first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                auto b = i-&amp;gt;second.second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                auto c = j-&amp;gt;second.first;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                auto d = j-&amp;gt;second.second;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (a != c &amp;amp;&amp;amp; a != d &amp;amp;&amp;amp; b != c &amp;amp;&amp;amp; b != d) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    vector&amp;lt;int&amp;gt; vec = &amp;#123; nums[a], nums[b], nums[c], nums[d] &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    sort(vec.begin(), vec.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    result.push_back(vec);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sort(result.begin(), result.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.erase(unique(result.begin(), result.end()), result.end());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;####code[java] – O(n^3)的版本&lt;/p&gt;
&lt;p&gt;这个还是用我们之前的理论来做。效果还行。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; fourSum(int[] nums, int target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; ans = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Arrays.sort(nums);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (nums.length &amp;lt; 4) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 0; i &amp;lt; nums.length - 3; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int j = i + 1; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (i &amp;gt; 0 &amp;amp;&amp;amp; nums[i] == nums[i-1])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                continue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while (j &amp;lt; nums.length - 2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                int k = j + 1, h = nums.length - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                while (k &amp;lt; h) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    if (nums[i] + nums[j] + nums[k] + nums[h] == target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        List&amp;lt;Integer&amp;gt; li = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(nums[i], nums[j], nums[k], nums[h]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        ans.add(li);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        while (k &amp;lt; nums.length - 1 &amp;amp;&amp;amp; nums[k] == nums[k+1]) k++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        while (h &amp;gt; k &amp;amp;&amp;amp; nums[h] == nums[h-1]) h--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        h--; k++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125; else if (nums[i] + nums[j] + nums[k] + nums[h] &amp;gt; target) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        h--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        k++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                while (j &amp;lt; nums.length -2 &amp;amp;&amp;amp; nums[j] == nums[j+1]) j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ans;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;leetcode里面出了一系列的这种题目，分别是two sum，3 sum，3 sum closed，4 sum。 期中出了two sum是利用hashmap外，其他基本的套路都是差不多的，都是先固定一个数字，然后进行左右夹逼的。时间复杂度基本就是O(n^(N-1)), 期中 N 就是指由多少个sum。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(III) BackTrack Review --- 回溯法题目总结</title>
    <link href="http://yu-zhengyu.github.com/note/2016/01/03/%E6%80%BB%E7%BB%93(III)%20BackTrack%20Review/"/>
    <id>http://yu-zhengyu.github.com/note/2016/01/03/总结(III) BackTrack Review/</id>
    <published>2016-01-03T14:22:30.000Z</published>
    <updated>2016-04-02T05:04:42.000Z</updated>
    
    <content type="html">&lt;p&gt;这种题目出现的频率还是比较高的，一般如果遇到题目类似于：排列组合，有多少个子类，subset等等。基本上都是同一套路，有暴力求解的意思，就是一个一个试，但是试的策略有所不同。如果遇到是数字的排列的情况，需要在求解之前进行排序。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;78-Subsets：-Given-a-set-of-distinct-integers-nums-return-all-possible-subsets&quot;&gt;&lt;a href=&quot;#78-Subsets：-Given-a-set-of-distinct-integers-nums-return-all-possible-subsets&quot; class=&quot;headerlink&quot; title=&quot;78. Subsets： Given a set of distinct integers, nums, return all possible subsets.&quot;&gt;&lt;/a&gt;78. Subsets： Given a set of distinct integers, nums, return all possible subsets.&lt;/h3&gt;&lt;p&gt;For example：&lt;/p&gt;
&lt;p&gt;If nums = [1,2,3], a solution is:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,3],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这题是典型的用回溯法的题目，我当时用的是python做的。因为这题是求子集，所以注意一下空集也算进去。下面直接上代码。&lt;/p&gt;
&lt;p&gt;####code[python]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Solution(object):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def subsets(self, nums):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :type nums: List[int]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :rtype: List[List[int]]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums.sort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.dfs(nums, 0, [], result)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def dfs(self, nums, index, temp, result):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.append(temp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for i in range(index, len(nums)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.dfs(nums, i + 1, temp + [nums[i]], result)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这种题目出现的频率还是比较高的，一般如果遇到题目类似于：排列组合，有多少个子类，subset等等。基本上都是同一套路，有暴力求解的意思，就是一个一个试，但是试的策略有所不同。如果遇到是数字的排列的情况，需要在求解之前进行排序。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>217. Contains Duplicate</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/29/217.%20Contains%20Duplicate/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/29/217. Contains Duplicate/</id>
    <published>2015-12-29T14:22:30.000Z</published>
    <updated>2016-04-02T05:06:26.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Difficulty-Easy&quot;&gt;&lt;a href=&quot;#Difficulty-Easy&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Easy&quot;&gt;&lt;/a&gt;Difficulty: Easy&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;这个问题非常简单，我的做法就是直接把数组放到set当中就好，然后看set的长度和原数组的长度是否相等，如果相等，就说明没有重复的元素，不相等说明有重复元素。&lt;/p&gt;
&lt;h3 id=&quot;Code-python&quot;&gt;&lt;a href=&quot;#Code-python&quot; class=&quot;headerlink&quot; title=&quot;Code[python]&quot;&gt;&lt;/a&gt;Code[python]&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # @param &amp;#123;integer[]&amp;#125; nums&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # @return &amp;#123;boolean&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def containsDuplicate(self, nums):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        b = set(nums)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if len(b) &amp;lt; len(nums):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return True&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return False&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然，如果对空间上有所要求，比如说，不能用额外的空间的话。那我们首先要对数组进行排序。那么时间上的话最快也就是O(nlogn)，然后遍历一遍，看看nums[i] == nums[i-1]是否成立。当然，有时候还有一些题目问在一个链表上，是否有重复元素。那么，我的做法就是用两个指针去做，时间上是O(n2).&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Difficulty-Easy&quot;&gt;&lt;a href=&quot;#Difficulty-Easy&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Easy&quot;&gt;&lt;/a&gt;Difficulty: Easy&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;br&gt;
    
    </summary>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(II) Graph and Tree Review --- 图和树的总结</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/29/%E6%80%BB%E7%BB%93(II)%20Graph%20and%20Tree%20Review/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/29/总结(II) Graph and Tree Review/</id>
    <published>2015-12-29T14:22:30.000Z</published>
    <updated>2016-04-02T05:04:50.000Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h2 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h2&gt;&lt;p&gt;图的话我现在也就基本掌握了&lt;strong&gt;&lt;em&gt;BFS&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;DFS&lt;/em&gt;&lt;/strong&gt;，在难的像什么有向图，流的搜索，拓扑排序，最小生成树什么的，大二考完试后除了记得大体思路外，具体编码已经忘记怎么做了。以后再慢慢进行补充好了。&lt;/p&gt;
&lt;p&gt;首先还是总结基本的算法。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;DFS&quot;&gt;&lt;a href=&quot;#DFS&quot; class=&quot;headerlink&quot; title=&quot;DFS&quot;&gt;&lt;/a&gt;DFS&lt;/h3&gt;&lt;p&gt;DFS其实就是把每次搜索的点加入到&lt;strong&gt;&lt;em&gt;栈&lt;/em&gt;&lt;/strong&gt;当中，一直搜索知道栈为空。这个方法有时候在树的问题也会用的到。下面是代码的基本思路。&lt;/p&gt;
&lt;p&gt;这个代码是找判断给出的两个节点是否联通，如果联通就返回ture，不连通返回false。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	enum State &amp;#123;Unvisit, Visited, Visting&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static boolean search(Graph g,Node start,Node end) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if(start == end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		for(Node u : g.getNodes())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			u.state = State.Unvisit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Stack&amp;lt;Node&amp;gt; s = new Stack&amp;lt;Node&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		start.state = State.Visting;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		s.push(start);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		while(!s.isEmpty()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Node current = s.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			if(current != null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				for(Node v : u.getAdjacent()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					if (v.state == State.Unvisit) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;						if(v == end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;							return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;						else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;							v.state = State.Visting;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;							s.push(v);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;						&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			current.state = State.Visited;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;BFS&quot;&gt;&lt;a href=&quot;#BFS&quot; class=&quot;headerlink&quot; title=&quot;BFS&quot;&gt;&lt;/a&gt;BFS&lt;/h3&gt;&lt;p&gt;BFS思想和DFS类似，把每次搜索的点都放进&lt;strong&gt;&lt;em&gt;队列&lt;/em&gt;&lt;/strong&gt;当中，一直搜索知道队列为空为止。代码和例子和上述差不多，就是把stack改成Queue即可。具体的以后再补充。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;p&gt;树一定要掌握的还是&lt;strong&gt;&lt;em&gt;前序，中序，后续&lt;/em&gt;&lt;/strong&gt;， 递归和非递归的方法都应该掌握。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;前序&quot;&gt;&lt;a href=&quot;#前序&quot; class=&quot;headerlink&quot; title=&quot;前序&quot;&gt;&lt;/a&gt;前序&lt;/h3&gt;&lt;p&gt;访问顺序是: 访问，左子树，右子树&lt;/p&gt;
&lt;p&gt;####code[java],递归版本&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ArrayList&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tral(result, root);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void tral(ArrayList&amp;lt;Integer&amp;gt; result, TreeNode root) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(root == null)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.add(root.val); // 中序则把这行放下一行，后序就把这行放到最后一行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tral(result, root.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tral(result, root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;####code[python],非递归版本&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution(object):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def preorderTraversal(self, root):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :type root: TreeNode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :rtype: List[int]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stac = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        p = root&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while len(stac) != 0 or p != None:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if p != None:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                stac.append(p)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                result.append(p.val)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                p = p.left&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                top =stac.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                p = top.right&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;中序和后序&quot;&gt;&lt;a href=&quot;#中序和后序&quot; class=&quot;headerlink&quot; title=&quot;中序和后序&quot;&gt;&lt;/a&gt;中序和后序&lt;/h3&gt;&lt;p&gt;基本上看了前序以后，中序和后序就差不多了。递归版本的话，就是读取和访问的顺序不同而已。上面已经在代码上标注了，下面再次把三种方式总结：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前序访问顺序是: 访问，左子树，右子树&lt;/li&gt;
&lt;li&gt;中序访问顺序是: 左子树，访问，右子树&lt;/li&gt;
&lt;li&gt;后序访问顺序是: 左子树，右子树，访问&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;树的构建&quot;&gt;&lt;a href=&quot;#树的构建&quot; class=&quot;headerlink&quot; title=&quot;树的构建&quot;&gt;&lt;/a&gt;树的构建&lt;/h3&gt;&lt;p&gt;比较基本的还有树的构建方面的题目，比如给出中序和后序访问的数组，构建一个树，或者给出前序和中序，构建一个树。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;####Construct Binary Tree from Inorder and Postorder Traversal&lt;/p&gt;
&lt;p&gt;####code[java] &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public TreeNode buildTree(int[] inorder, int[] postorder) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int rootindex = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(inorder==null || postorder==null || inorder.length==0 || postorder.length==0) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TreeNode root = new TreeNode(postorder[postorder.length - 1]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(postorder.length==1) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; inorder.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(inorder[i] == postorder[postorder.length - 1]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rootindex = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] inleft = Arrays.copyOfRange(inorder, 0, rootindex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] inright = Arrays.copyOfRange(inorder, rootindex + 1, inorder.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] postleft = Arrays.copyOfRange(postorder, 0, rootindex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] postright = Arrays.copyOfRange(postorder, rootindex, postorder.length - 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root.left = buildTree(inleft, postleft);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root.right = buildTree(inright, postright);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;####Construct Binary Tree from Preorder and Inorder Traversal&lt;/p&gt;
&lt;p&gt;####code[java]&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public TreeNode buildTree(int[] preorder, int[] inorder) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int rootindex = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(inorder==null || preorder==null || inorder.length==0 || preorder.length==0) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        TreeNode root = new TreeNode(preorder[0]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(preorder.length==1) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; inorder.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(inorder[i] == preorder[0]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                rootindex = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] inleft = Arrays.copyOfRange(inorder, 0, rootindex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] inright = Arrays.copyOfRange(inorder, rootindex + 1, inorder.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] preleft = Arrays.copyOfRange(preorder, 1, rootindex + 1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] preright = Arrays.copyOfRange(preorder, rootindex + 1, preorder.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root.left = buildTree(preleft, inleft);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        root.right = buildTree(preright, inright);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return root;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h2 id=&quot;图&quot;&gt;&lt;a href=&quot;#图&quot; class=&quot;headerlink&quot; title=&quot;图&quot;&gt;&lt;/a&gt;图&lt;/h2&gt;&lt;p&gt;图的话我现在也就基本掌握了&lt;strong&gt;&lt;em&gt;BFS&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;DFS&lt;/em&gt;&lt;/st
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>总结(I) Array and String Review --- 数组类和String题目总结</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/29/%E6%80%BB%E7%BB%93(I)%20Array%20and%20String%20Review/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/29/总结(I) Array and String Review/</id>
    <published>2015-12-29T14:22:30.000Z</published>
    <updated>2016-04-02T05:05:53.000Z</updated>
    
    <content type="html">&lt;p&gt;这几篇我会归类总结一下做过的题目。总体会根据《Cracking the Code interview 189》这本书来进行复习。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;Write-a-method-anagram-s-t-to-decide-if-two-strings-are-anagrams-or-not&quot;&gt;&lt;a href=&quot;#Write-a-method-anagram-s-t-to-decide-if-two-strings-are-anagrams-or-not&quot; class=&quot;headerlink&quot; title=&quot;Write a method anagram(s,t) to decide if two strings are anagrams or not.&quot;&gt;&lt;/a&gt;Write a method anagram(s,t) to decide if two strings are anagrams or not.&lt;/h3&gt;&lt;p&gt;这题是google一道面试题。题目的意思很简单，就看一个String是不是另一个String重新排序后的结果。方法很多。比较好的做法是开一个int[256], 分别扫一遍String，把相应字符的ASCII码记录。然后相互对比。又或者扫第一个字符串的时候，每一个相应字符下的数量+1，扫第二个的时候就-1，然后看看所有数组是不是都是0，这样的时间复杂度是O(N), 空间的话是O(N). 还有比较SB的方法。把字符排序，然后直接对比，这样时间复杂度是O(nlogn).&lt;/p&gt;
&lt;p&gt;lintcode上有个follow up说能不能用O(n) time, O(1) extra space，我的想法是用bit 来做。利用相同的数字异或后结果为0. 然后我们就可以判断了。这样就只是用了O(1) extra space。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param s: The first string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @param b: The second string&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * @return true or false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean anagram(String s, String t) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // write your code here&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int result = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(s.length() != t.length())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; s.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result ^= s.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result ^= t.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(result == 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Check-if-the-String-is-unique&quot;&gt;&lt;a href=&quot;#Check-if-the-String-is-unique&quot; class=&quot;headerlink&quot; title=&quot;Check if the String is unique.&quot;&gt;&lt;/a&gt;Check if the String is unique.&lt;/h3&gt;&lt;p&gt;这题也是比较高频的。其实可以直接用HashTable直接记下每一个字母出现的字数，如果有字母已经出现了，那么就返回false即可。当然，面试的时候follow up可能会要求你不要用extra data structure. 那么HashTable就不可以用了。 我们可以用一个int数组来解决一个问题。还是和上题一样，用一个256位的数组储存每一个字母出现的次数，如果发现改字母的数据已经不是0了，就可以返回false了。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static boolean isUniqueNoExtraDataStructure(String testStr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int alphabetInt = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    String str = testStr.toLowerCase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i = 0; i &amp;lt; str.length(); i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int val = str.charAt(i) - &amp;apos;a&amp;apos;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ((alphabetInt &amp;amp; (1 &amp;lt;&amp;lt; val)) &amp;gt; 0)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alphabetInt |= (1 &amp;lt;&amp;lt; val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我还发现了一个比较贱的做法，就是用String的API，String有一个方法叫indexOf和lastIndexOf。分别是求出一个字符的首次出现的下标和最后一次出现的下标。那这就简单了。当一个字符的第一个下标和最后一个下标都相等，那就说明它只出现了一次。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static boolean compareUnique(String a) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	boolean result = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for(int i = 0; i &amp;lt; a.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (a.indexOf(a.charAt(i)) != a.lastIndexOf(a.charAt(i))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			result = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;check-the-if-sentence-is-palinpermutation&quot;&gt;&lt;a href=&quot;#check-the-if-sentence-is-palinpermutation&quot; class=&quot;headerlink&quot; title=&quot;check the if sentence is palinpermutation&quot;&gt;&lt;/a&gt;check the if sentence is palinpermutation&lt;/h3&gt;&lt;p&gt;回文，比较经典的一道题目。考法太多。还有专门的算法来求一个长String中求出最长回文的，&lt;a href=&quot;http://blog.csdn.net/yzl_rex/article/details/7908259&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Manacher算法：求解最长回文字符串，时间复杂度为O(N)&lt;/a&gt;，等有空在回过头来看。&lt;/p&gt;
&lt;p&gt;测一个字符串是不是回文还是比较简单。CC里面的题目稍微增加点难度，字符串中可能会有空格。在处理的时候要小心处理空格的部分即可。&lt;/p&gt;
&lt;p&gt;for example：“Tact Coa” 就是一个回文字符串。&lt;/p&gt;
&lt;p&gt;那么，这个题目可以有几种做法。我比较喜欢的就是用双指针来做，不会使用太多的空间。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean isPalindrome(String s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int i = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int j = s.length() - 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(s.length() == 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        while(i &amp;lt; j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 略过不是数字和字母的情况&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(!Character.isLetterOrDigit(s.charAt(i)) &amp;amp;&amp;amp; i &amp;lt; j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            while(!Character.isLetterOrDigit(s.charAt(j)) &amp;amp;&amp;amp; i &amp;lt; j)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            char a = Character.toLowerCase(s.charAt(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            char b = Character.toLowerCase(s.charAt(j));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if(a != b)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // 开始对比下一个字符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return i &amp;gt;= j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;stringcompress&quot;&gt;&lt;a href=&quot;#stringcompress&quot; class=&quot;headerlink&quot; title=&quot;stringcompress&quot;&gt;&lt;/a&gt;stringcompress&lt;/h3&gt;&lt;p&gt;我是没想到有面试会出现这个。还是挺经典的。就是把相同的字母用数字和字母进行概括。比如说：aaabbbccc就替换成3a3b3c.所以直接上代码了。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static String stringcompress(String s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int count = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	StringBuffer result = new StringBuffer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int i = 0; i &amp;lt; s.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if ((i + 1) == s.length() || s.charAt(i) != s.charAt(i + 1)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			result.append(s.charAt(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			result.append(count);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			count = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (result.toString().length() &amp;lt; s.length())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		return result.toString();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;check-if-the-s2-is-the-rotate-from-s1&quot;&gt;&lt;a href=&quot;#check-if-the-s2-is-the-rotate-from-s1&quot; class=&quot;headerlink&quot; title=&quot;check if the s2 is the rotate from s1&quot;&gt;&lt;/a&gt;check if the s2 is the rotate from s1&lt;/h3&gt;&lt;p&gt;这题就是技巧问题了。如果一个字符串是另一个字符串的rotation，那么其实将S2拼接上S1的尾部，然后查看S2是否是新字符串的字串即可。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static boolean isrotate (String s1, String s2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if (s1.length() != s2.length())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			return false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	String newstring = s1 + s1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return newstring.contains(s2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&quot;Reverse-a-sentenace-such-as-“code-is-good”-after-reverse-it-would-become-“good-is-code”&quot;&gt;&lt;a href=&quot;#Reverse-a-sentenace-such-as-“code-is-good”-after-reverse-it-would-become-“good-is-code”&quot; class=&quot;headerlink&quot; title=&quot;Reverse a sentenace. such as “code is good”, after reverse, it would become “good is code”.&quot;&gt;&lt;/a&gt;Reverse a sentenace. such as “code is good”, after reverse, it would become “good is code”.&lt;/h3&gt;&lt;p&gt;翻转一个句子，一个一个单词进行翻转。这题一开始我还是懵了。后来发现也挺简单。用给一个下标来进行遍历。如果遇到一个空格，就重头开始插入。否则就一直顺着原来的顺序进行插入。看了代码就明白了，还是比较巧妙。&lt;/p&gt;
&lt;p&gt;####code[java]&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	String str = &amp;quot;much. very you love I&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	System.out.println(reverse(str));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public static String reverse(String s) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	int pos = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	StringBuilder sb = new StringBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (int i = 0; i &amp;lt; s.length(); i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		char c = s.charAt(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (c == &amp;apos; &amp;apos;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			pos = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		sb.insert(pos, c);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		if (c != &amp;apos; &amp;apos;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			pos++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return sb.toString();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h2&gt;&lt;h3 id=&quot;basci-skill&quot;&gt;&lt;a href=&quot;#basci-skill&quot; class=&quot;headerlink&quot; title=&quot;basci skill&quot;&gt;&lt;/a&gt;basci skill&lt;/h3&gt;&lt;p&gt;Reverse a array in java.&lt;br&gt;比较会常用的一种，记一下。当然也可以用库函数：&lt;strong&gt;&lt;em&gt;Collections.reverse(Arrays.asList(nums));&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void reverse(int[] nums, int left, int right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(left&amp;lt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int temp = nums[left];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums[left]=nums[right];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nums[right]=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        left++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        right--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这几篇我会归类总结一下做过的题目。总体会根据《Cracking the Code interview 189》这本书来进行复习。&lt;br&gt;
    
    </summary>
    
      <category term="总结" scheme="http://yu-zhengyu.github.com/note/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>62.Unique Paths</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/28/62.Unique%20Paths/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/28/62.Unique Paths/</id>
    <published>2015-12-28T14:22:30.000Z</published>
    <updated>2016-04-02T05:06:40.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Difficulty-Medium&quot;&gt;&lt;a href=&quot;#Difficulty-Medium&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Medium&quot;&gt;&lt;/a&gt;Difficulty: Medium&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;这题比较简单，也是我比较后悔的一题，因为人生中第一次面试就是面试这题。这题其实就是最简单的DP做法即可。采用缓存备忘的形式避免重复计算。当然也可以用自底向上的方法，转移方程就是：当前坐标的path数 = 上坐标的path数 + 左坐标的path数。&lt;/p&gt;
&lt;p&gt;公式：path = f[m][n-1] + f[m-1][n].&lt;/p&gt;
&lt;h3 id=&quot;Code-python&quot;&gt;&lt;a href=&quot;#Code-python&quot; class=&quot;headerlink&quot; title=&quot;Code[python]&quot;&gt;&lt;/a&gt;Code[python]&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Solution(object):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def uniquePaths(self, m, n):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :type m: int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :type n: int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        :rtype: int&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        tt = [[-1 for i in range(0, n+1)] for j in range(0, m+1)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp = self.conunt(m, n, tt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return temp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    def conunt(self, m, n, tt):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if tt[m][n] != -1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return tt[m][n]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if m == 1 or n == 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            tt[m][n] = self.conunt(m - 1, n, tt) + self.conunt(m, n - 1, tt)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return tt[m][n]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Difficulty-Medium&quot;&gt;&lt;a href=&quot;#Difficulty-Medium&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Medium&quot;&gt;&lt;/a&gt;Difficulty: Medium&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).&lt;/p&gt;
&lt;p&gt;The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).&lt;/p&gt;
&lt;p&gt;How many possible unique paths are there?&lt;br&gt;
    
    </summary>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>41.First Missing Positive</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/28/41.%20First-missing-positive/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/28/41. First-missing-positive/</id>
    <published>2015-12-28T14:22:30.000Z</published>
    <updated>2016-04-02T05:06:52.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Difficulty-Hard&quot;&gt;&lt;a href=&quot;#Difficulty-Hard&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Hard&quot;&gt;&lt;/a&gt;Difficulty: Hard&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;Given an unsorted integer array, find the first missing positive integer.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;For example,&lt;/p&gt;
&lt;p&gt;Given &lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;return ```3```,&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;and ```[3,4,-1,1]``` return ```2```.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Your algorithm should run in O(n) time and uses constant space.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Solution&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个题目我其实不是很理解，基本原理就是桶排序。每当 ```A[i]!= i+1``` 的时候,就把```A[i] 与 A[A[i]-1] 交换```，一直到当```A[i] == A[A[i]-1]```。这里借助网上一个朋友的图来说明这个过程。```这里尤其注意一下两个数字交换的位置。我这里犯了N次错误。因为当你将nums[i]改变的时候，如果不事先保存下标，就很容易出错。所以保险的交换做法应该就像我这样做。如果你有更好的做法，可以提出&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://yu-zhengyu.github.io/static/img/review/41_1.png&quot; width=&quot;400&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个题目我其实不是很理解，基本原理就是桶排序。每当 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;i+1``` 的时候,就把```A[i] 与 A[A[i]-1] 交换```，一直到当```A[i] == A[A[i]-1]```。这里借助网上一个朋友的图来说明这个过程。&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个题目现在终于比较理解了，其实就是把具体的数字放在指定的坐标就好。如果index为1的是不是在数组的 index 相对的位置上，如果不是，交换，然后一直交换到超出了该数组的范围或者已经交换到对了的情况。不知道这种算不算桶排序的思想。我觉得桶排序说得就太让人迷惑了。不如说，看数组中的数字和数组的下标是否相等即可。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### Code[java]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;public class Solution {&lt;br&gt;    public int firstMissingPositive(int[] nums) {&lt;br&gt;        int i = 0;&lt;br&gt;        int n = nums.length;&lt;br&gt;        while(i &amp;lt; n) {&lt;br&gt;            if(nums[i] &amp;gt; 0 &amp;amp;&amp;amp; nums[i] &amp;lt;= n &amp;amp;&amp;amp; nums[i] != i + 1 &amp;amp;&amp;amp; nums[i] != nums[nums[i]- 1]) {&lt;br&gt;                int temp = nums[i];&lt;br&gt;                int temp2 = nums[nums[i]- 1];&lt;br&gt;                int tempindex = i;&lt;br&gt;                int tempindex2 = nums[i]- 1;&lt;br&gt;                nums[tempindex2] = temp;&lt;br&gt;                nums[tempindex] = temp2;&lt;br&gt;            }&lt;br&gt;            else&lt;br&gt;                i++;&lt;br&gt;        }&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    for(int j = 0; j &amp;lt; n; j++) {
        if(nums[j] != j + 1)
            return j + 1;
    }
    return n + 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}&lt;br&gt;```&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Difficulty-Hard&quot;&gt;&lt;a href=&quot;#Difficulty-Hard&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Hard&quot;&gt;&lt;/a&gt;Difficulty: Hard&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;Given an unsorted integer array, find the first missing positive integer.&lt;br&gt;
    
    </summary>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>313.Super Ugly Number</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/28/313.Super%20Ugly%20Number/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/28/313.Super Ugly Number/</id>
    <published>2015-12-28T14:22:30.000Z</published>
    <updated>2016-04-02T05:06:20.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Difficulty-Medium&quot;&gt;&lt;a href=&quot;#Difficulty-Medium&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Medium&quot;&gt;&lt;/a&gt;Difficulty: Medium&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;Write a program to find the nth super ugly number.&lt;/p&gt;
&lt;p&gt;Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k. For example, &lt;figure class=&quot;highlight plain&quot;&gt;&lt;figcaption&gt;&lt;span&gt;2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]``` is the sequence of the first 12 super ugly numbers given ```primes = [2, 7, 13, 19]``` of size 4.&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!--more--&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## Solution&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个问题的解法其实和```Ugly NumberII```差不多，我们拿当factor是```[2, 3, 5]```来当例子。如果我们把这些丑陋数字列出来的话，我们能发现其中的规律：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(1) 1×2, 2×2, 3×2, 4×2, 5×2, …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(2) 1×3, 2×3, 3×3, 4×3, 5×3, …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(3) 1×5, 2×5, 3×5, 4×5, 5×5, …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以，其实我们只要每一次对前一个丑陋数乘上相应的factor，然后从中取出最小的一个数就好。然后相应的下标+1. ```这里注意，如果有不止一个最小的数，那么所有数的下标都应该+1，在下做这题的时候就犯了这个错误，结果总会出现重复的数字。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import java.util.Vector;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int nthSuperUglyNumber(int n, int[] primes) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int size = primes.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] clist = new int[size];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] result = new int[n];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result[0] = 1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 1; i &amp;lt; n; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            int minnum = Integer.MAX_VALUE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            Vector&amp;lt;Integer&amp;gt; templist = new Vector&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for(int j = 0; j &amp;lt; size; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                int temp = primes[j] * result[clist[j]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                templist.add(temp);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(temp &amp;lt; minnum) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    minnum = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for(int p = 0; p &amp;lt; templist.size(); p++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if(templist.get(p) == minnum)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    clist[p]++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            result[i] = minnum;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return result[n - 1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Difficulty-Medium&quot;&gt;&lt;a href=&quot;#Difficulty-Medium&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Medium&quot;&gt;&lt;/a&gt;Difficulty: Medium&lt;/h3&gt;&lt;h2 id=&quot;Por
    
    </summary>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>319.Bulb Switcher</title>
    <link href="http://yu-zhengyu.github.com/note/2015/12/28/319.%20Bulb-Switcher/"/>
    <id>http://yu-zhengyu.github.com/note/2015/12/28/319. Bulb-Switcher/</id>
    <published>2015-12-28T14:22:30.000Z</published>
    <updated>2016-04-02T05:06:06.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Difficulty-Medium&quot;&gt;&lt;a href=&quot;#Difficulty-Medium&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Medium&quot;&gt;&lt;/a&gt;Difficulty: Medium&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;Example:&lt;/p&gt;
&lt;p&gt;Given n = 3. &lt;/p&gt;
&lt;p&gt;At first, the three bulbs are [off, off, off].&lt;/p&gt;
&lt;p&gt;After first round, the three bulbs are [on, on, on].&lt;/p&gt;
&lt;p&gt;After second round, the three bulbs are [on, off, on].&lt;/p&gt;
&lt;p&gt;After third round, the three bulbs are [on, off, off]. &lt;/p&gt;
&lt;p&gt;So you should return 1, because there is only one bulb is on.&lt;/p&gt;
&lt;h2 id=&quot;Solution&quot;&gt;&lt;a href=&quot;#Solution&quot; class=&quot;headerlink&quot; title=&quot;Solution&quot;&gt;&lt;/a&gt;Solution&lt;/h2&gt;&lt;p&gt;这个问题其实就是一个数学问题，一个一个试，找出规律后你就会发现其实最后只会剩下平方数下标的灯泡会亮，例如：1，2，4，9，16…… 所以这一题就很简单了，直接对n开方，取整就是最后的结果，简单暴力。&lt;/p&gt;
&lt;h3 id=&quot;Code&quot;&gt;&lt;a href=&quot;#Code&quot; class=&quot;headerlink&quot; title=&quot;Code&quot;&gt;&lt;/a&gt;Code&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class Solution &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public int bulbSwitch(int n) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (int)Math.sqrt(n);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Difficulty-Medium&quot;&gt;&lt;a href=&quot;#Difficulty-Medium&quot; class=&quot;headerlink&quot; title=&quot;Difficulty: Medium&quot;&gt;&lt;/a&gt;Difficulty: Medium&lt;/h3&gt;&lt;h2 id=&quot;Porblem&quot;&gt;&lt;a href=&quot;#Porblem&quot; class=&quot;headerlink&quot; title=&quot;Porblem&quot;&gt;&lt;/a&gt;Porblem&lt;/h2&gt;&lt;p&gt;There are n bulbs that are initially off. You first turn on all the bulbs. Then, you turn off every second bulb. On the third round, you toggle every third bulb (turning on if it’s off or turning off if it’s on). For the nth round, you only toggle the last bulb. Find how many bulbs are on after n rounds.&lt;br&gt;
    
    </summary>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://yu-zhengyu.github.com/note/tags/leetcode/"/>
    
      <category term="刷题" scheme="http://yu-zhengyu.github.com/note/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yu-zhengyu.github.com/note/1991/08/08/hello-world/"/>
    <id>http://yu-zhengyu.github.com/note/1991/08/08/hello-world/</id>
    <published>1991-08-08T13:22:30.000Z</published>
    <updated>2016-04-01T23:20:52.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
